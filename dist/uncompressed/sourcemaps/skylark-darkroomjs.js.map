{"version":3,"sources":["skylark-darkroomjs.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-darkroomjs.js","sourcesContent":["define('skylark-darkroomjs/Darkroom',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-widgets-base/Widget\",\r\n    \"skylark-fabric\"\r\n], function(skylark, langx, noder,finder,Widget,fabric) {\r\n  'use strict';\r\n\r\n  var Plugins = {};\r\n\r\n  function computeImageViewPort(image) {\r\n    //return {\r\n    //  height : image.height,\r\n    //  width : image.width\r\n    //};\r\n    return {\r\n      height: Math.abs(image.getScaledWidth() * (Math.sin(image.angle * Math.PI/180))) + Math.abs(image.getScaledHeight() * (Math.cos(image.angle * Math.PI/180))),\r\n      width: Math.abs(image.getScaledHeight() * (Math.sin(image.angle * Math.PI/180))) + Math.abs(image.getScaledWidth() * (Math.cos(image.angle * Math.PI/180))),\r\n    }\r\n  }\r\n\r\n // Toolbar object.\r\n  function Toolbar(element) {\r\n    this.element = element;\r\n  }\r\n\r\n  Toolbar.prototype = {\r\n    createButtonGroup: function(options) {\r\n      var buttonGroup = document.createElement('div');\r\n      buttonGroup.className = 'darkroom-button-group';\r\n      this.element.appendChild(buttonGroup);\r\n\r\n      return new ButtonGroup(buttonGroup);\r\n    }\r\n  };\r\n\r\n  // ButtonGroup object.\r\n  function ButtonGroup(element) {\r\n    this.element = element;\r\n  }\r\n\r\n  ButtonGroup.prototype = {\r\n    createButton: function(options) {\r\n      var defaults = {\r\n        image: 'help',\r\n        type: 'default',\r\n        group: 'default',\r\n        hide: false,\r\n        disabled: false\r\n      };\r\n\r\n      options = langx.mixin({},defaults,options);\r\n\r\n      var buttonElement = document.createElement('button');\r\n      buttonElement.type = 'button';\r\n      buttonElement.className = 'darkroom-button darkroom-button-' + options.type;\r\n      buttonElement.innerHTML = '<svg class=\"darkroom-icon\"><use xlink:href=\"#' + options.image + '\" /></svg>';\r\n      this.element.appendChild(buttonElement);\r\n\r\n      var button = new Button(buttonElement);\r\n      button.hide(options.hide);\r\n      button.disable(options.disabled);\r\n\r\n      return button;\r\n    }\r\n  }\r\n\r\n  // Button object.\r\n  function Button(element) {\r\n    this.element = element;\r\n  }\r\n\r\n  Button.prototype = {\r\n    addEventListener: function(eventName, listener) {\r\n      if (this.element.addEventListener){\r\n        this.element.addEventListener(eventName, listener);\r\n      } else if (this.element.attachEvent) {\r\n        this.element.attachEvent('on' + eventName, listener);\r\n      }\r\n    },\r\n    removeEventListener: function(eventName, listener) {\r\n      if (this.element.removeEventListener){\r\n        this.element.removeEventListener(eventName, listener);\r\n      }\r\n    },\r\n    active: function(value) {\r\n      if (value)\r\n        this.element.classList.add('darkroom-button-active');\r\n      else\r\n        this.element.classList.remove('darkroom-button-active');\r\n    },\r\n    hide: function(value) {\r\n      if (value)\r\n        this.element.classList.add('darkroom-button-hidden');\r\n      else\r\n        this.element.classList.remove('darkroom-button-hidden');\r\n    },\r\n    disable: function(value) {\r\n      this.element.disabled = (value) ? true : false;\r\n    }\r\n  };\r\n\r\n  var Darkroom = Widget.inherit({\r\n    klassName : \"Darkroom\",\r\n\r\n    /*\r\n     * @param {Element} el The container element. \r\n     */\r\n    _construct : function(el,options,plugins) {\r\n      if (typeof el === 'string') {\r\n        el = finder.find(el);\r\n      }\r\n\r\n      this._initializeDOM(el);\r\n      this.overrided(this.containerElement,options);\r\n      //this.options = langx.mixin({}, this.defaults,options);\r\n\r\n      // List of the instancied plugins\r\n      this.plugins = {};\r\n\r\n//      var image = new Image();\r\n//      image.onload = function() {\r\n        // Initialize the DOM/fabric elements\r\n        this._initializeImage();\r\n\r\n        // Then initialize the plugins\r\n        this._initializePlugins();\r\n\r\n        // Public method to adjust image according to the canvas\r\n        this.refresh(function() {\r\n          // Execute a custom callback after initialization\r\n          this.options.initialize.bind(this).call();\r\n        }.bind(this));\r\n\r\n  //    }.bind(this)\r\n\r\n      //image.crossOrigin = 'anonymous';\r\n      //image.src = el.src;\r\n    },\r\n\r\n    // Reference to the main container element\r\n    containerElement: null,\r\n\r\n    // Reference to the fabric canvas object\r\n    canvas: null,\r\n\r\n    // Reference to the fabric image object\r\n    image: null,\r\n\r\n    // Reference to the fabric source canvas object\r\n    sourceCanvas: null,\r\n\r\n    // Reference to the fabric source image object\r\n    sourceImage: null,\r\n\r\n    // Track of the original image element\r\n    originalImageElement: null,\r\n\r\n    // Stack of transformations to apply to the image source\r\n    transformations: [],\r\n\r\n    // Default options\r\n    options: {\r\n      // Canvas properties (dimension, ratio, color)\r\n      minWidth: null,\r\n      minHeight: null,\r\n      maxWidth: null,\r\n      maxHeight: null,\r\n      ratio: null,\r\n      backgroundColor: '#fff',\r\n\r\n      // Plugins options\r\n      plugins: {},\r\n\r\n      // Post-initialisation callback\r\n      initialize: function() { /* noop */ }\r\n    },\r\n\r\n\r\n\r\n    selfDestroy: function() {\r\n      var container = this.containerElement;\r\n      var image = new Image();\r\n      image.onload = function() {\r\n        container.parentNode.replaceChild(image, container);\r\n      }\r\n\r\n      image.src = this.sourceImage.toDataURL();\r\n    },\r\n\r\n    // Add ability to attach event listener on the core object.\r\n    // It uses the canvas element to process events.\r\n    addEventListener: function(eventName, callback) {\r\n      var el = this.canvas.getElement();\r\n      if (el.addEventListener){\r\n        el.addEventListener(eventName, callback);\r\n      } else if (el.attachEvent) {\r\n        el.attachEvent('on' + eventName, callback);\r\n      }\r\n    },\r\n\r\n    dispatchEvent: function(eventName) {\r\n      // Use the old way of creating event to be IE compatible\r\n      // See https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events\r\n      var event = document.createEvent('Event');\r\n      event.initEvent(eventName, true, true);\r\n\r\n      this.canvas.getElement().dispatchEvent(event);\r\n    },\r\n\r\n    // Adjust image & canvas dimension according to min/max width/height\r\n    // and ratio specified in the options.\r\n    // This method should be called after each image transformation.\r\n    refresh: function(next) {\r\n      var clone = new Image();\r\n      clone.onload = function() {\r\n        this._replaceCurrentImage(new fabric.Image(clone));\r\n\r\n        if (next) next();\r\n      }.bind(this);\r\n      clone.src = this.sourceImage.toDataURL();\r\n    },\r\n\r\n    _replaceCurrentImage: function(newImage) {\r\n      if (this.image) {\r\n        this.image.canvas.remove(this.image);\r\n      }\r\n\r\n      this.image = newImage;\r\n      this.image.selectable = false;\r\n\r\n      // Adjust width or height according to specified ratio\r\n      var viewport = computeImageViewPort(this.image);\r\n      var canvasWidth = viewport.width;\r\n      var canvasHeight = viewport.height;\r\n\r\n      if (null !== this.options.ratio) {\r\n        var canvasRatio = +this.options.ratio;\r\n        var currentRatio = canvasWidth / canvasHeight;\r\n\r\n        if (currentRatio > canvasRatio) {\r\n          canvasHeight = canvasWidth / canvasRatio;\r\n        } else if (currentRatio < canvasRatio) {\r\n          canvasWidth = canvasHeight * canvasRatio;\r\n        }\r\n      }\r\n\r\n      // Then scale the image to fit into dimension limits\r\n      var scaleMin = 1;\r\n      var scaleMax = 1;\r\n      var scaleX = 1;\r\n      var scaleY = 1;\r\n\r\n      if (null !== this.options.maxWidth && this.options.maxWidth < canvasWidth) {\r\n        scaleX =  this.options.maxWidth / canvasWidth;\r\n      }\r\n      if (null !== this.options.maxHeight && this.options.maxHeight < canvasHeight) {\r\n        scaleY =  this.options.maxHeight / canvasHeight;\r\n      }\r\n      scaleMin = Math.min(scaleX, scaleY);\r\n\r\n      scaleX = 1;\r\n      scaleY = 1;\r\n      if (null !== this.options.minWidth && this.options.minWidth > canvasWidth) {\r\n        scaleX =  this.options.minWidth / canvasWidth;\r\n      }\r\n      if (null !== this.options.minHeight && this.options.minHeight > canvasHeight) {\r\n        scaleY =  this.options.minHeight / canvasHeight;\r\n      }\r\n      scaleMax = Math.max(scaleX, scaleY);\r\n\r\n      var scale = scaleMax * scaleMin; // one should be equals to 1\r\n\r\n      canvasWidth *= scale;\r\n      canvasHeight *= scale;\r\n\r\n      // Finally place the image in the center of the canvas\r\n      this.image.scaleX = (1 * scale);\r\n      this.image.scaleY = (1 * scale);\r\n      this.canvas.add(this.image);\r\n      this.canvas.setWidth(canvasWidth);\r\n      this.canvas.setHeight(canvasHeight);\r\n      this.canvas.centerObject(this.image);\r\n      this.image.setCoords();\r\n    },\r\n\r\n    // Apply the transformation on the current image and save it in the\r\n    // transformations stack (in order to reconstitute the previous states\r\n    // of the image).\r\n    applyTransformation: function(transformation) {\r\n      this.transformations.push(transformation);\r\n\r\n      transformation.applyTransformation(\r\n        this.sourceCanvas,\r\n        this.sourceImage,\r\n        this._postTransformation.bind(this)\r\n      );\r\n    },\r\n\r\n    _postTransformation: function(newImage) {\r\n      if (newImage)\r\n        this.sourceImage = newImage;\r\n\r\n      this.refresh(function() {\r\n        this.dispatchEvent('core:transformation');\r\n      }.bind(this));\r\n    },\r\n\r\n    // Initialize image from original element plus re-apply every\r\n    // transformations.\r\n    reinitializeImage: function() {\r\n      this.canvas.remove(this.sourceImage);\r\n      this._initializeImage();\r\n      this._popTransformation(this.transformations.slice())\r\n    },\r\n\r\n    _popTransformation: function(transformations) {\r\n      if (0 === transformations.length) {\r\n        this.dispatchEvent('core:reinitialized');\r\n        this.refresh();\r\n        return;\r\n      }\r\n\r\n      var transformation = transformations.shift();\r\n\r\n      var next = function(newImage) {\r\n        if (newImage) this.sourceImage = newImage;\r\n        this._popTransformation(transformations)\r\n      };\r\n\r\n      transformation.applyTransformation(\r\n        this.sourceCanvas,\r\n        this.sourceImage,\r\n        next.bind(this)\r\n      );\r\n    },\r\n\r\n    // Create the DOM elements and instanciate the fabric canvas.\r\n    // The image element is replaced by a new `div` element.\r\n    // However the original image is re-injected in order to keep a trace of it.\r\n    _initializeDOM: function(imageElement) {\r\n      // Container\r\n      var mainContainerElement = document.createElement('div');\r\n      mainContainerElement.className = 'darkroom-container';\r\n\r\n      // Toolbar\r\n      var toolbarElement = document.createElement('div');\r\n      toolbarElement.className = 'darkroom-toolbar';\r\n      mainContainerElement.appendChild(toolbarElement);\r\n\r\n      // Viewport canvas\r\n      var canvasContainerElement = document.createElement('div');\r\n      canvasContainerElement.className = 'darkroom-image-container';\r\n      var canvasElement = this.canvasElement = document.createElement('canvas');\r\n      canvasContainerElement.appendChild(canvasElement);\r\n      mainContainerElement.appendChild(canvasContainerElement);\r\n\r\n      // Source canvas\r\n      var sourceCanvasContainerElement = document.createElement('div');\r\n      sourceCanvasContainerElement.className = 'darkroom-source-container';\r\n      sourceCanvasContainerElement.style.display = 'none';\r\n      var sourceCanvasElement = this.sourceCanvasElement = document.createElement('canvas');\r\n      sourceCanvasContainerElement.appendChild(sourceCanvasElement);\r\n      mainContainerElement.appendChild(sourceCanvasContainerElement);\r\n\r\n      // Original image\r\n      imageElement.parentNode.replaceChild(mainContainerElement, imageElement);\r\n      imageElement.style.display = 'none';\r\n      mainContainerElement.appendChild(imageElement);\r\n\r\n      // Instanciate object from elements\r\n      this.containerElement = mainContainerElement;\r\n      this.originalImageElement = imageElement;\r\n\r\n      this.toolbar = new Toolbar(toolbarElement);\r\n\r\n    },\r\n\r\n    // Instanciate the fabric image object.\r\n    // The image is created as a static element with no control,\r\n    // then it is add in the fabric canvas object.\r\n    _initializeImage: function() {\r\n      this.canvas = new fabric.Canvas(this.canvasElement, {\r\n        selection: false,\r\n        backgroundColor: this.options.backgroundColor\r\n      });\r\n\r\n      this.sourceCanvas = new fabric.Canvas(this.sourceCanvasElement, {\r\n        selection: false,\r\n        backgroundColor: this.options.backgroundColor\r\n      });\r\n \r\n      this.sourceImage = new fabric.Image(this.originalImageElement, {\r\n        // Some options to make the image static\r\n        selectable: false,\r\n        evented: false,\r\n        lockMovementX: true,\r\n        lockMovementY: true,\r\n        lockRotation: true,\r\n        lockScalingX: true,\r\n        lockScalingY: true,\r\n        lockUniScaling: true,\r\n        hasControls: false,\r\n        hasBorders: false,\r\n      });\r\n\r\n      this.sourceCanvas.add(this.sourceImage);\r\n\r\n      // Adjust width or height according to specified ratio\r\n      var viewport = computeImageViewPort(this.sourceImage);\r\n      var canvasWidth = viewport.width;\r\n      var canvasHeight = viewport.height;\r\n\r\n      this.sourceCanvas.setWidth(canvasWidth);\r\n      this.sourceCanvas.setHeight(canvasHeight);\r\n      this.sourceCanvas.centerObject(this.sourceImage);\r\n      this.sourceImage.setCoords();\r\n    },\r\n\r\n    // Initialize every plugins.\r\n    // Note that plugins are instanciated in the same order than they\r\n    // are declared in the parameter object.\r\n    _initializePlugins: function() {\r\n      for (var name in Plugins) {\r\n        var pluginInfo = Plugins[name];\r\n        var options = this.options.plugins[name];\r\n\r\n        // Setting false into the plugin options will disable the plugin\r\n        if (options === false)\r\n          continue;\r\n\r\n        // Avoid any issues with _proto_\r\n        if (!Plugins.hasOwnProperty(name))\r\n          continue;\r\n\r\n        this.plugins[name] = new pluginInfo.ctor(this, options);\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n\r\n  Darkroom.Plugin = langx.Evented.inherit({\r\n    klassName : \"Plugin\",\r\n\r\n    defaults: {},\r\n\r\n    init : function(Darkroom,options) {\r\n      this.Darkroom = Darkroom;\r\n      this.options = langx.mixin({},this.defaults,options);\r\n\r\n    }\r\n  });\r\n\r\n\r\n  Darkroom.Transformation = langx.Evented.inherit({\r\n    klassName : \"Transformation\",\r\n\r\n    init : function(options) {\r\n      this.options = options;\r\n    }\r\n  });\r\n\r\n\r\n  Darkroom.installPlugin = function(setting) {\r\n\r\n    //Plugins.push(setting);\r\n    Plugins[setting.name] = setting;\r\n  };\r\n\r\n  return skylark.attach(\"intg.Darkroom\",Darkroom);\r\n\r\n});\r\n\r\n\ndefine('skylark-darkroomjs/plugins/history',[\r\n  \"skylark-langx/langx\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-query\",\r\n  \"skylark-fabric\",\r\n  '../Darkroom',\r\n],function(langx,noder, $, fabric,Darkroom) {\r\n  'use strict';\r\n\r\n  var HistoryPlugin= Darkroom.Plugin.inherit({\r\n     undoTransformations: null,\r\n\r\n     init : function(Darkroom,options) {\r\n      this.overrided(Darkroom,options);\r\n      this.undoTransformations = [];\r\n      this._initButtons();\r\n\r\n      this.Darkroom.addEventListener('core:transformation', this._onTranformationApplied.bind(this));\r\n    },\r\n\r\n    undo: function() {\r\n      if (this.Darkroom.transformations.length === 0) {\r\n        return;\r\n      }\r\n\r\n      var lastTransformation = this.Darkroom.transformations.pop();\r\n      this.undoTransformations.unshift(lastTransformation);\r\n\r\n      this.Darkroom.reinitializeImage();\r\n      this._updateButtons();\r\n    },\r\n\r\n    redo: function() {\r\n      if (this.undoTransformations.length === 0) {\r\n        return;\r\n      }\r\n\r\n      var cancelTransformation = this.undoTransformations.shift();\r\n      this.Darkroom.transformations.push(cancelTransformation);\r\n\r\n      this.Darkroom.reinitializeImage();\r\n      this._updateButtons();\r\n    },\r\n\r\n    _initButtons: function() {\r\n      var buttonGroup = this.Darkroom.toolbar.createButtonGroup();\r\n\r\n      this.backButton = buttonGroup.createButton({\r\n        image: 'undo',\r\n        disabled: true\r\n      });\r\n\r\n      this.forwardButton = buttonGroup.createButton({\r\n        image: 'redo',\r\n        disabled: true\r\n      });\r\n\r\n      this.backButton.addEventListener('click', this.undo.bind(this));\r\n      this.forwardButton.addEventListener('click', this.redo.bind(this));\r\n\r\n      return this;\r\n    },\r\n\r\n    _updateButtons: function() {\r\n      this.backButton.disable((this.Darkroom.transformations.length === 0))\r\n      this.forwardButton.disable((this.undoTransformations.length === 0))\r\n    },\r\n\r\n    _onTranformationApplied: function() {\r\n      this.undoTransformations = [];\r\n      this._updateButtons();\r\n    }\r\n  });\r\n\r\n  var pluginInfo = {\r\n    name : \"history\",\r\n    ctor : HistoryPlugin\r\n  };\r\n\r\n  Darkroom.installPlugin(pluginInfo);\r\n\r\n  return pluginInfo;\r\n\r\n  \r\n});\r\n\ndefine('skylark-darkroomjs/plugins/crop',[\r\n  \"skylark-langx/langx\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-images\",\r\n  \"skylark-domx-query\",\r\n  \"skylark-fabric\",\r\n  '../Darkroom',\r\n],function(langx,noder, images,$, fabric,Darkroom) {\r\n  'use strict';\r\n\r\n  function computeImageViewPort(image) {\r\n    //return {\r\n    //  height : image.height,\r\n    //  width : image.width\r\n    //};\r\n    return {\r\n      height: Math.abs(image.getScaledWidth() * (Math.sin(image.get(\"angle\") * Math.PI/180))) + Math.abs(image.getScaledHeight() * (Math.cos(image.get(\"angle\") * Math.PI/180))),\r\n      width: Math.abs(image.getScaledHeight() * (Math.sin(image.get(\"angle\") * Math.PI/180))) + Math.abs(image.getScaledWidth() * (Math.cos(image.get(\"angle\") * Math.PI/180))),\r\n    }\r\n  }\r\n  \r\n\r\n  var Crop = Darkroom.Transformation.inherit({\r\n    applyTransformation: function(canvas, image, next) {\r\n      // Snapshot the image delimited by the crop zone\r\n      var snapshot = new Image();\r\n\r\n      var viewport = computeImageViewPort(image);\r\n      var imageWidth = viewport.width;\r\n      var imageHeight = viewport.height;\r\n\r\n      var left = this.options.left * imageWidth;\r\n      var top = this.options.top * imageHeight;\r\n      var width = Math.min(this.options.width * imageWidth, imageWidth - left);\r\n      var height = Math.min(this.options.height * imageHeight, imageHeight - top);\r\n\r\n      snapshot.src = canvas.toDataURL({\r\n        left: left,\r\n        top: top,\r\n        width: width,\r\n        height: height,\r\n      });\r\n\r\n      images.loaded(snapshot).then(function() {\r\n        // Validate image\r\n        if (height < 1 || width < 1)\r\n          return;\r\n\r\n        var imgInstance = new fabric.Image(snapshot, {\r\n          // options to make the image static\r\n          selectable: false,\r\n          evented: false,\r\n          lockMovementX: true,\r\n          lockMovementY: true,\r\n          lockRotation: true,\r\n          lockScalingX: true,\r\n          lockScalingY: true,\r\n          lockUniScaling: true,\r\n          hasControls: false,\r\n          hasBorders: false\r\n        });\r\n\r\n        var width = snapshot.width;\r\n        var height = snapshot.height;\r\n\r\n        // Update canvas size\r\n        canvas.setWidth(width);\r\n        canvas.setHeight(height);\r\n\r\n        // Add image\r\n        canvas.remove(image);\r\n        canvas.add(imgInstance);\r\n\r\n        next(imgInstance);\r\n      });\r\n    }\r\n  });\r\n\r\n  var CropZone = fabric.util.createClass(fabric.Rect, {\r\n    _render: function(ctx) {\r\n      this.callSuper('_render', ctx);\r\n\r\n      var canvas = ctx.canvas;\r\n      var dashWidth = 7;\r\n\r\n      // Set original scale\r\n      var flipX = this.flipX ? -1 : 1;\r\n      var flipY = this.flipY ? -1 : 1;\r\n      var scaleX = flipX / this.scaleX;\r\n      var scaleY = flipY / this.scaleY;\r\n\r\n      ctx.scale(scaleX, scaleY);\r\n\r\n      // Overlay rendering\r\n      //ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; //modifeied by lwf\r\n      this._renderOverlay(ctx);\r\n\r\n      // Set dashed borders\r\n      if (ctx.setLineDash !== undefined)\r\n        ctx.setLineDash([dashWidth, dashWidth]);\r\n      else if (ctx.mozDash !== undefined)\r\n        ctx.mozDash = [dashWidth, dashWidth];\r\n\r\n      // First lines rendering with black\r\n      ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';\r\n      this._renderBorders(ctx);\r\n      this._renderGrid(ctx);\r\n\r\n      // Re render lines in white\r\n      ctx.lineDashOffset = dashWidth;\r\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';\r\n      this._renderBorders(ctx);\r\n      this._renderGrid(ctx);\r\n\r\n      // Reset scale\r\n      ctx.scale(1/scaleX, 1/scaleY);\r\n    },\r\n\r\n    _renderOverlay: function(ctx) {\r\n      var canvas = ctx.canvas;\r\n\r\n      //\r\n      //    x0    x1        x2      x3\r\n      // y0 +------------------------+\r\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\r\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\r\n      // y1 +------+---------+-------+\r\n      //    |\\\\\\\\\\\\|         |\\\\\\\\\\\\\\|\r\n      //    |\\\\\\\\\\\\|    0    |\\\\\\\\\\\\\\|\r\n      //    |\\\\\\\\\\\\|         |\\\\\\\\\\\\\\|\r\n      // y2 +------+---------+-------+\r\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\r\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\r\n      // y3 +------------------------+\r\n      //\r\n\r\n      var x0 = Math.ceil(-this.getScaledWidth() / 2 - this.left);\r\n      var x1 = Math.ceil(-this.getScaledWidth() / 2);\r\n      var x2 = Math.ceil(this.getScaledWidth() / 2);\r\n      var x3 = Math.ceil(this.getScaledWidth() / 2 + (canvas.width - this.getScaledWidth() - this.left));\r\n\r\n      var y0 = Math.ceil(-this.getScaledHeight() / 2 - this.top);\r\n      var y1 = Math.ceil(-this.getScaledHeight() / 2);\r\n      var y2 = Math.ceil(this.getScaledHeight() / 2);\r\n      var y3 = Math.ceil(this.getScaledHeight() / 2 + (canvas.height - this.getScaledHeight() - this.top));\r\n\r\n      ctx.beginPath();\r\n      \r\n      // Draw outer rectangle.\r\n      // Numbers are +/-1 so that overlay edges don't get blurry.\r\n      ctx.moveTo(x0 - 1, y0 - 1);\r\n      ctx.lineTo(x3 + 1, y0 - 1);\r\n      ctx.lineTo(x3 + 1, y3 + 1);\r\n      ctx.lineTo(x0 - 1, y3 - 1);\r\n      ctx.lineTo(x0 - 1, y0 - 1);\r\n      ctx.closePath();\r\n\r\n      // Draw inner rectangle.\r\n      ctx.moveTo(x1, y1);\r\n      ctx.lineTo(x1, y2);\r\n      ctx.lineTo(x2, y2);\r\n      ctx.lineTo(x2, y1);\r\n      ctx.lineTo(x1, y1);\r\n\r\n      ctx.closePath();\r\n      ctx.fill();\r\n    },\r\n\r\n    _renderBorders: function(ctx) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(-this.getScaledWidth()/2, -this.getScaledHeight()/2); // upper left\r\n      ctx.lineTo(this.getScaledWidth()/2, -this.getScaledHeight()/2); // upper right\r\n      ctx.lineTo(this.getScaledWidth()/2, this.getScaledHeight()/2); // down right\r\n      ctx.lineTo(-this.getScaledWidth()/2, this.getScaledHeight()/2); // down left\r\n      ctx.lineTo(-this.getScaledWidth()/2, -this.getScaledHeight()/2); // upper left\r\n      ctx.stroke();\r\n    },\r\n\r\n    _renderGrid: function(ctx) {\r\n      \r\n      // Vertical lines\r\n      ctx.beginPath();\r\n      ctx.moveTo(-this.getScaledWidth()/2 + 1/3 * this.getScaledWidth(), -this.getScaledHeight()/2);\r\n      ctx.lineTo(-this.getScaledWidth()/2 + 1/3 * this.getScaledWidth(), this.getScaledHeight()/2);\r\n      ctx.stroke();\r\n      ctx.beginPath();\r\n      ctx.moveTo(-this.getScaledWidth()/2 + 2/3 * this.getScaledWidth(), -this.getScaledHeight()/2);\r\n      ctx.lineTo(-this.getScaledWidth()/2 + 2/3 * this.getScaledWidth(), this.getScaledHeight()/2);\r\n      ctx.stroke();\r\n      // Horizontal lines\r\n      ctx.beginPath();\r\n      ctx.moveTo(-this.getScaledWidth()/2, -this.getScaledHeight()/2 + 1/3 * this.getScaledHeight());\r\n      ctx.lineTo(this.getScaledWidth()/2, -this.getScaledHeight()/2 + 1/3 * this.getScaledHeight());\r\n      ctx.stroke();\r\n      ctx.beginPath();\r\n      ctx.moveTo(-this.getScaledWidth()/2, -this.getScaledHeight()/2 + 2/3 * this.getScaledHeight());\r\n      ctx.lineTo(this.getScaledWidth()/2, -this.getScaledHeight()/2 + 2/3 * this.getScaledHeight());\r\n      ctx.stroke();\r\n    }\r\n  });\r\n\r\n  var CropPlugin = Darkroom.Plugin.inherit({\r\n    // Init point\r\n    startX: null,\r\n    startY: null,\r\n\r\n    // Keycrop\r\n    isKeyCroping: false,\r\n    isKeyLeft: false,\r\n    isKeyUp: false,\r\n\r\n    defaults: {\r\n      // min crop dimension\r\n      minHeight: 1,\r\n      minWidth: 1,\r\n      // ensure crop ratio\r\n      ratio: null,\r\n      // quick crop feature (set a key code to enable it)\r\n      quickCropKey: false\r\n    },\r\n\r\n     init : function(Darkroom,options) {\r\n      this.overrided(Darkroom,options);\r\n      var buttonGroup = this.Darkroom.toolbar.createButtonGroup();\r\n\r\n      this.cropButton = buttonGroup.createButton({\r\n        image: 'crop'\r\n      });\r\n      this.okButton = buttonGroup.createButton({\r\n        image: 'done',\r\n        type: 'success',\r\n        hide: true\r\n      });\r\n      this.cancelButton = buttonGroup.createButton({\r\n        image: 'close',\r\n        type: 'danger',\r\n        hide: true\r\n      });\r\n\r\n      // Buttons click\r\n      this.cropButton.addEventListener('click', this.toggleCrop.bind(this));\r\n      this.okButton.addEventListener('click', this.cropCurrentZone.bind(this));\r\n      this.cancelButton.addEventListener('click', this.releaseFocus.bind(this));\r\n\r\n      // Canvas events\r\n      this.Darkroom.canvas.on('mouse:down', this.onMouseDown.bind(this));\r\n      this.Darkroom.canvas.on('mouse:move', this.onMouseMove.bind(this));\r\n      this.Darkroom.canvas.on('mouse:up', this.onMouseUp.bind(this));\r\n      this.Darkroom.canvas.on('object:moving', this.onObjectMoving.bind(this));\r\n      this.Darkroom.canvas.on('object:scaling', this.onObjectScaling.bind(this));\r\n\r\n      fabric.util.addListener(document, 'keydown', this.onKeyDown.bind(this));\r\n      fabric.util.addListener(document, 'keyup', this.onKeyUp.bind(this));\r\n\r\n      this.Darkroom.addEventListener('core:transformation', this.releaseFocus.bind(this));\r\n    },\r\n\r\n    // Avoid crop zone to go beyond the canvas edges\r\n    onObjectMoving: function(event) {\r\n      if (!this.hasFocus()) {\r\n        return;\r\n      }\r\n\r\n      var currentObject = event.target;\r\n      if (currentObject !== this.cropZone)\r\n        return;\r\n\r\n      var canvas = this.Darkroom.canvas;\r\n      var x = currentObject.left, y = currentObject.top;\r\n      var w = currentObject.getScaledWidth(), h = currentObject.getScaledHeight();\r\n      var maxX = canvas.getWidth() - w;\r\n      var maxY = canvas.getHeight() - h;\r\n\r\n      if (x < 0)\r\n        currentObject.set('left', 0);\r\n      if (y < 0)\r\n        currentObject.set('top', 0);\r\n      if (x > maxX)\r\n        currentObject.set('left', maxX);\r\n      if (y > maxY)\r\n        currentObject.set('top', maxY);\r\n\r\n      this.Darkroom.dispatchEvent('crop:update');\r\n    },\r\n\r\n    // Prevent crop zone from going beyond the canvas edges (like mouseMove)\r\n    onObjectScaling: function(event) {\r\n      if (!this.hasFocus()) {\r\n        return;\r\n      }\r\n\r\n      var preventScaling = false;\r\n      var currentObject = event.target;\r\n      if (currentObject !== this.cropZone)\r\n        return;\r\n\r\n      var canvas = this.Darkroom.canvas;\r\n      var pointer = canvas.getPointer(event.e);\r\n      var x = pointer.x;\r\n      var y = pointer.y;\r\n\r\n      var minX = currentObject.left;\r\n      var minY = currentObject.top;\r\n      var maxX = currentObject.left + currentObject.getScaledWidth();\r\n      var maxY = currentObject.top + currentObject.getScaledHeight();\r\n\r\n      if (null !== this.options.ratio) {\r\n        if (minX < 0 || maxX > canvas.getWidth() || minY < 0 || maxY > canvas.getHeight()) {\r\n          preventScaling = true;\r\n        }\r\n      }\r\n\r\n      if (minX < 0 || maxX > canvas.getWidth() || preventScaling) {\r\n        var lastScaleX = this.lastScaleX || 1;\r\n        currentObject.setScaleX(lastScaleX);\r\n      }\r\n      if (minX < 0) {\r\n        currentObject.setLeft(0);\r\n      }\r\n\r\n      if (minY < 0 || maxY > canvas.getHeight() || preventScaling) {\r\n        var lastScaleY = this.lastScaleY || 1;\r\n        currentObject.setScaleY(lastScaleY);\r\n      }\r\n      if (minY < 0) {\r\n        currentObject.setTop(0);\r\n      }\r\n\r\n      if (currentObject.get(\"width\") < this.options.minWidth) {\r\n        currentObject.scaleToWidth(this.options.minWidth);\r\n      }\r\n      if (currentObject.get(\"height\") < this.options.minHeight) {\r\n        currentObject.scaleToHeight(this.options.minHeight);\r\n      }\r\n\r\n      this.lastScaleX = currentObject.get(\"scaleX\");\r\n      this.lastScaleY = currentObject.get(\"scaleY\");\r\n\r\n      this.Darkroom.dispatchEvent('crop:update');\r\n    },\r\n\r\n    // Init crop zone\r\n    onMouseDown: function(event) {\r\n      if (!this.hasFocus()) {\r\n        return;\r\n      }\r\n\r\n      var canvas = this.Darkroom.canvas;\r\n\r\n      // recalculate offset, in case canvas was manipulated since last `calcOffset`\r\n      canvas.calcOffset();\r\n      var pointer = canvas.getPointer(event.e);\r\n      var x = pointer.x;\r\n      var y = pointer.y;\r\n      var point = new fabric.Point(x, y);\r\n\r\n      // Check if user want to scale or drag the crop zone.\r\n      var activeObject = canvas.getActiveObject();\r\n      if (activeObject === this.cropZone || this.cropZone.containsPoint(point)) {\r\n        return;\r\n      }\r\n\r\n      canvas.discardActiveObject();\r\n      this.cropZone.set(\"width\",0);\r\n      this.cropZone.set(\"height\",0);\r\n      this.cropZone.set(\"scaleX\",1);\r\n      this.cropZone.set(\"scaleY\",1);\r\n\r\n      this.startX = x;\r\n      this.startY = y;\r\n    },\r\n\r\n    // Extend crop zone\r\n    onMouseMove: function(event) {\r\n      // Quick crop feature\r\n      if (this.isKeyCroping)\r\n        return this.onMouseMoveKeyCrop(event);\r\n\r\n      if (null === this.startX || null === this.startY) {\r\n        return;\r\n      }\r\n\r\n      var canvas = this.Darkroom.canvas;\r\n      var pointer = canvas.getPointer(event.e);\r\n      var x = pointer.x;\r\n      var y = pointer.y;\r\n\r\n      this._renderCropZone(this.startX, this.startY, x, y);\r\n    },\r\n\r\n    onMouseMoveKeyCrop: function(event) {\r\n      var canvas = this.Darkroom.canvas;\r\n      var zone = this.cropZone;\r\n\r\n      var pointer = canvas.getPointer(event.e);\r\n      var x = pointer.x;\r\n      var y = pointer.y;\r\n\r\n      if (!zone.left || !zone.top) {\r\n        zone.set(\"top\",y);\r\n        zone.set(\"left\",x);\r\n      }\r\n\r\n      this.isKeyLeft =  x < zone.left + zone.width / 2 ;\r\n      this.isKeyUp = y < zone.top + zone.height / 2 ;\r\n\r\n      this._renderCropZone(\r\n        Math.min(zone.left, x),\r\n        Math.min(zone.top, y),\r\n        Math.max(zone.left+zone.width, x),\r\n        Math.max(zone.top+zone.height, y)\r\n      );\r\n    },\r\n\r\n    // Finish crop zone\r\n    onMouseUp: function(event) {\r\n      if (null === this.startX || null === this.startY) {\r\n        return;\r\n      }\r\n\r\n      var canvas = this.Darkroom.canvas;\r\n      this.cropZone.setCoords();\r\n      canvas.setActiveObject(this.cropZone);\r\n      canvas.calcOffset();\r\n\r\n      this.startX = null;\r\n      this.startY = null;\r\n    },\r\n\r\n    onKeyDown: function(event) {\r\n      if (false === this.options.quickCropKey || event.keyCode !== this.options.quickCropKey || this.isKeyCroping)\r\n        return;\r\n\r\n      // Active quick crop flow\r\n      this.isKeyCroping = true ;\r\n      this.Darkroom.canvas.discardActiveObject();\r\n      this.cropZone.set(\"width\",0);\r\n      this.cropZone.set(\"height\",0);\r\n      this.cropZone.set(\"scaleX\",1);\r\n      this.cropZone.set(\"scaleY\",1);\r\n      this.cropZone.set(\"top\",0);\r\n      this.cropZone.set(\"left\",0);\r\n    },\r\n\r\n    onKeyUp: function(event) {\r\n      if (false === this.options.quickCropKey || event.keyCode !== this.options.quickCropKey || !this.isKeyCroping)\r\n        return;\r\n\r\n      // Unactive quick crop flow\r\n      this.isKeyCroping = false;\r\n      this.startX = 1;\r\n      this.startY = 1;\r\n      this.onMouseUp();\r\n    },\r\n\r\n    selectZone: function(x, y, width, height, forceDimension) {\r\n      if (!this.hasFocus())\r\n        this.requireFocus();\r\n\r\n      if (!forceDimension) {\r\n        this._renderCropZone(x, y, x+width, y+height);\r\n      } else {\r\n        this.cropZone.set({\r\n          'left': x,\r\n          'top': y,\r\n          'width': width,\r\n          'height': height\r\n        });\r\n      }\r\n\r\n      var canvas = this.Darkroom.canvas;\r\n      canvas.bringToFront(this.cropZone);\r\n      this.cropZone.setCoords();\r\n      canvas.setActiveObject(this.cropZone);\r\n      canvas.calcOffset();\r\n\r\n      this.Darkroom.dispatchEvent('crop:update');\r\n    },\r\n\r\n    toggleCrop: function() {\r\n      if (!this.hasFocus())\r\n        this.requireFocus();\r\n      else\r\n        this.releaseFocus();\r\n    },\r\n\r\n    cropCurrentZone: function() {\r\n      if (!this.hasFocus())\r\n        return;\r\n\r\n      // Avoid croping empty zone\r\n      if (this.cropZone.width < 1 && this.cropZone.height < 1)\r\n        return;\r\n\r\n      var image = this.Darkroom.image;\r\n\r\n      // Compute crop zone dimensions\r\n      var top = this.cropZone.get(\"top\") - image.get(\"top\");\r\n      var left = this.cropZone.get(\"left\") - image.get(\"left\");\r\n      var width = this.cropZone.get(\"width\");\r\n      var height = this.cropZone.get(\"height\");\r\n\r\n      // Adjust dimensions to image only\r\n      if (top < 0) {\r\n        height += top;\r\n        top = 0;\r\n      }\r\n\r\n      if (left < 0) {\r\n        width += left;\r\n        left = 0;\r\n      }\r\n\r\n      // Apply crop transformation.\r\n      // Make sure to use relative dimension since the crop will be applied\r\n      // on the source image.\r\n      this.Darkroom.applyTransformation(new Crop({\r\n        top: top / image.getScaledHeight(),\r\n        left: left / image.getScaledWidth(),\r\n        width: width / image.getScaledWidth(),\r\n        height: height / image.getScaledHeight(),\r\n      }));\r\n    },\r\n\r\n    // Test wether crop zone is set\r\n    hasFocus: function() {\r\n      return this.cropZone !== undefined;\r\n    },\r\n\r\n    // Create the crop zone\r\n    requireFocus: function() {\r\n      this.cropZone = new CropZone({\r\n        fill: 'transparent',\r\n        hasBorders: false,\r\n        originX: 'left',\r\n        originY: 'top',\r\n        //stroke: '#444',\r\n        //strokeDashArray: [5, 5],\r\n        //borderColor: '#444',\r\n        cornerColor: '#444',\r\n        cornerSize: 8,\r\n        transparentCorners: false,\r\n        lockRotation: true,\r\n        hasRotatingPoint: false,\r\n      });\r\n\r\n      if (null !== this.options.ratio) {\r\n        this.cropZone.set('lockUniScaling', true);\r\n      }\r\n\r\n      this.Darkroom.canvas.add(this.cropZone);\r\n      this.Darkroom.canvas.defaultCursor = 'crosshair';\r\n\r\n      this.cropButton.active(true);\r\n      this.okButton.hide(false);\r\n      this.cancelButton.hide(false);\r\n    },\r\n\r\n    // Remove the crop zone\r\n    releaseFocus: function() {\r\n      if (undefined === this.cropZone)\r\n        return;\r\n\r\n      this.cropZone.canvas.remove(this.cropZone);\r\n      this.cropZone = undefined;\r\n\r\n      this.cropButton.active(false);\r\n      this.okButton.hide(true);\r\n      this.cancelButton.hide(true);\r\n\r\n      this.Darkroom.canvas.defaultCursor = 'default';\r\n\r\n      this.Darkroom.dispatchEvent('crop:update');\r\n    },\r\n\r\n    _renderCropZone: function(fromX, fromY, toX, toY) {\r\n      var canvas = this.Darkroom.canvas;\r\n\r\n      var isRight = (toX > fromX);\r\n      var isLeft = !isRight;\r\n      var isDown = (toY > fromY);\r\n      var isUp = !isDown;\r\n\r\n      var minWidth = Math.min(+this.options.minWidth, canvas.getWidth());\r\n      var minHeight = Math.min(+this.options.minHeight, canvas.getHeight());\r\n\r\n      // Define corner coordinates\r\n      var leftX = Math.min(fromX, toX);\r\n      var rightX = Math.max(fromX, toX);\r\n      var topY = Math.min(fromY, toY);\r\n      var bottomY = Math.max(fromY, toY);\r\n\r\n      // Replace current point into the canvas\r\n      leftX = Math.max(0, leftX);\r\n      rightX = Math.min(canvas.getWidth(), rightX);\r\n      topY = Math.max(0, topY)\r\n      bottomY = Math.min(canvas.getHeight(), bottomY);\r\n\r\n      // Recalibrate coordinates according to given options\r\n      if (rightX - leftX < minWidth) {\r\n        if (isRight)\r\n          rightX = leftX + minWidth;\r\n        else\r\n          leftX = rightX - minWidth;\r\n      }\r\n      if (bottomY - topY < minHeight) {\r\n        if (isDown)\r\n          bottomY = topY + minHeight;\r\n        else\r\n          topY = bottomY - minHeight;\r\n      }\r\n\r\n      // Truncate truncate according to canvas dimensions\r\n      if (leftX < 0) {\r\n        // Translate to the left\r\n        rightX += Math.abs(leftX);\r\n        leftX = 0\r\n      }\r\n      if (rightX > canvas.getWidth()) {\r\n        // Translate to the right\r\n        leftX -= (rightX - canvas.getWidth());\r\n        rightX = canvas.getWidth();\r\n      }\r\n      if (topY < 0) {\r\n        // Translate to the bottom\r\n        bottomY += Math.abs(topY);\r\n        topY = 0\r\n      }\r\n      if (bottomY > canvas.getHeight()) {\r\n        // Translate to the right\r\n        topY -= (bottomY - canvas.getHeight());\r\n        bottomY = canvas.getHeight();\r\n      }\r\n\r\n      var width = rightX - leftX;\r\n      var height = bottomY - topY;\r\n      var currentRatio = width / height;\r\n\r\n      if (this.options.ratio && +this.options.ratio !== currentRatio) {\r\n        var ratio = +this.options.ratio;\r\n\r\n        if(this.isKeyCroping) {\r\n          isLeft = this.isKeyLeft;\r\n          isUp = this.isKeyUp;\r\n        }\r\n\r\n        if (currentRatio < ratio) {\r\n          var newWidth = height * ratio;\r\n          if (isLeft) {\r\n            leftX -= (newWidth - width);\r\n          }\r\n          width = newWidth;\r\n        } else if (currentRatio > ratio) {\r\n          var newHeight = height / (ratio * height/width);\r\n          if (isUp) {\r\n            topY -= (newHeight - height);\r\n          }\r\n          height = newHeight;\r\n        }\r\n\r\n        if (leftX < 0) {\r\n          leftX = 0;\r\n          //TODO\r\n        }\r\n        if (topY < 0) {\r\n          topY = 0;\r\n          //TODO\r\n        }\r\n        if (leftX + width > canvas.getWidth()) {\r\n          var newWidth = canvas.getWidth() - leftX;\r\n          height = newWidth * height / width;\r\n          width = newWidth;\r\n          if (isUp) {\r\n            topY = fromY - height;\r\n          }\r\n        }\r\n        if (topY + height > canvas.getHeight()) {\r\n          var newHeight = canvas.getHeight() - topY;\r\n          width = width * newHeight / height;\r\n          height = newHeight;\r\n          if (isLeft) {\r\n            leftX = fromX - width;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Apply coordinates\r\n      this.cropZone.left = leftX;\r\n      this.cropZone.top = topY;\r\n      this.cropZone.width = width;\r\n      this.cropZone.height = height;\r\n\r\n      this.Darkroom.canvas.bringToFront(this.cropZone);\r\n\r\n      this.Darkroom.dispatchEvent('crop:update');\r\n    }\r\n  });\r\n\r\n  var pluginInfo = {\r\n    name : \"crop\",\r\n    ctor : CropPlugin\r\n  };\r\n\r\n  Darkroom.installPlugin(pluginInfo);\r\n\r\n  return pluginInfo;\r\n\r\n});\r\n\ndefine('skylark-darkroomjs/plugins/rotate',[\r\n  \"skylark-langx/langx\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-query\",\r\n  \"skylark-fabric\",\r\n  '../Darkroom',\r\n],function(langx,noder, $, fabric,Darkroom) {\r\n  'use strict';\r\n\r\nvar Rotation = Darkroom.Transformation.inherit({\r\n\r\n  applyTransformation: function(canvas, image, next) {\r\n    var angle = (image.angle + this.options.angle) % 360;\r\n    image.rotate(angle);\r\n\r\n    var width, height;\r\n    height = Math.abs(image.getScaledWidth()*(Math.sin(angle*Math.PI/180)))+Math.abs(image.getScaledHeight()*(Math.cos(angle*Math.PI/180)));\r\n    width = Math.abs(image.getScaledHeight()*(Math.sin(angle*Math.PI/180)))+Math.abs(image.getScaledWidth()*(Math.cos(angle*Math.PI/180)));\r\n\r\n    canvas.setWidth(width);\r\n    canvas.setHeight(height);\r\n\r\n    canvas.centerObject(image);\r\n    image.setCoords();\r\n    canvas.renderAll();\r\n\r\n    next();\r\n  }\r\n});\r\n\r\n\r\n  var RotatePlugin = Darkroom.Plugin.inherit({\r\n    init: function(Darkroom,options) {\r\n      this.overrided(Darkroom,options);\r\n      var buttonGroup = this.Darkroom.toolbar.createButtonGroup();\r\n\r\n      var leftButton = buttonGroup.createButton({\r\n        image: 'rotate-left'\r\n      });\r\n\r\n      var rightButton = buttonGroup.createButton({\r\n        image: 'rotate-right'\r\n      });\r\n\r\n      leftButton.addEventListener('click', this.rotateLeft.bind(this));\r\n      rightButton.addEventListener('click', this.rotateRight.bind(this));\r\n    },\r\n\r\n    rotateLeft: function() {\r\n      this.rotate(-90);\r\n    },\r\n\r\n    rotateRight: function() {\r\n      this.rotate(90);\r\n    },\r\n\r\n    rotate: function rotate(angle) {\r\n      this.Darkroom.applyTransformation(\r\n        new Rotation({angle: angle})\r\n      );\r\n    }\r\n  });\r\n\r\n  var pluginInfo = {\r\n    name : \"rotate\",\r\n    ctor : RotatePlugin\r\n  };\r\n\r\n  Darkroom.installPlugin(pluginInfo);\r\n\r\n  return pluginInfo;\r\n\r\n});\r\n\ndefine('skylark-darkroomjs/plugins/save',[\r\n  \"skylark-langx/langx\",\r\n  \"skylark-domx-noder\",\r\n  \"skylark-domx-query\",\r\n  \"skylark-fabric\",\r\n  '../Darkroom',\r\n],function(langx,noder, $, fabric,Darkroom) {\r\n  'use strict';\r\n\r\n  var SavePlugin= Darkroom.Plugin.inherit({\r\n\r\n    defaults: {\r\n      callback: function() {\r\n        this.Darkroom.selfDestroy();\r\n      }\r\n    },\r\n\r\n    init: function(Darkroom,options) {\r\n      this.overrided(Darkroom,options);\r\n\r\n      var buttonGroup = this.Darkroom.toolbar.createButtonGroup();\r\n\r\n      this.destroyButton = buttonGroup.createButton({\r\n        image: 'save'\r\n      });\r\n\r\n      this.destroyButton.addEventListener('click', this.options.callback.bind(this));\r\n    },\r\n  });\r\n\r\n  var pluginInfo = {\r\n    name : \"save\",\r\n    ctor : SavePlugin\r\n  };\r\n\r\n  Darkroom.installPlugin(pluginInfo);\r\n\r\n  return pluginInfo;  \r\n\r\n});\r\n\ndefine('skylark-darkroomjs/main',[\r\n    \"./Darkroom\",\r\n    \"./plugins/history\",\r\n    \"./plugins/crop\",\r\n    \"./plugins/rotate\",\r\n    \"./plugins/save\"\r\n], function(Darkroom) {\r\n    return Darkroom;\r\n})\r\n;\ndefine('skylark-darkroomjs', ['skylark-darkroomjs/main'], function (main) { return main; });\n\n"]}