{"version":3,"sources":["skylark-ui-imager.js"],"names":["factory","globals","absolute","relative","base","stack","split","parts","pop","i","length","push","join","define","require","isAmd","amd","isCmd","exports","map","id","deps","dep","hasOwnProperty","Error","module","args","forEach","apply","window","skylarkjs","skylark","langx","noder","finder","widgets","canvas2d","UI","computeImageViewPort","image","height","Math","abs","getWidth","sin","getAngle","PI","getHeight","cos","width","Toolbar","element","this","ButtonGroup","Button","ui","Plugins","prototype","createButtonGroup","options","buttonGroup","document","createElement","className","appendChild","createButton","defaults","type","group","hide","disabled","mixin","buttonElement","innerHTML","button","disable","addEventListener","eventName","listener","attachEvent","removeEventListener","active","value","classList","add","remove","Imager","Widget","inherit","klassName","init","el","plugins","find","_initializeDOM","overrided","containerElement","_initializeImage","_initializePlugins","refresh","initialize","bind","call","canvas","sourceCanvas","sourceImage","originalImageElement","transformations","minWidth","minHeight","maxWidth","maxHeight","ratio","backgroundColor","selfDestroy","container","Image","onload","parentNode","replaceChild","src","toDataURL","callback","getElement","dispatchEvent","event","createEvent","initEvent","next","clone","_replaceCurrentImage","newImage","selectable","viewport","canvasWidth","canvasHeight","canvasRatio","currentRatio","scaleMin","scaleMax","scaleX","scaleY","min","max","scale","setScaleX","setScaleY","setWidth","setHeight","centerObject","setCoords","applyTransformation","transformation","_postTransformation","reinitializeImage","_popTransformation","slice","shift","imageElement","mainContainerElement","toolbarElement","canvasContainerElement","canvasElement","sourceCanvasContainerElement","style","display","sourceCanvasElement","toolbar","Canvas","selection","evented","lockMovementX","lockMovementY","lockRotation","lockScalingX","lockScalingY","lockUniScaling","hasControls","hasBorders","name","pluginInfo","ctor","Plugin","Evented","imager","Transformation","installPlugin","setting","$","HistoryPlugin","undoTransformations","_initButtons","_onTranformationApplied","undo","lastTransformation","unshift","_updateButtons","redo","cancelTransformation","backButton","forwardButton","images","Crop","snapshot","imageWidth","imageHeight","left","top","loaded","then","imgInstance","CropZone","util","createClass","Rect","_render","ctx","callSuper","dashWidth","flipX","flipY","fillStyle","_renderOverlay","undefined","setLineDash","mozDash","strokeStyle","_renderBorders","_renderGrid","lineDashOffset","x0","ceil","getLeft","x1","x2","x3","y0","getTop","y1","y2","y3","beginPath","moveTo","lineTo","closePath","fill","stroke","CropPlugin","startX","startY","isKeyCroping","isKeyLeft","isKeyUp","quickCropKey","cropButton","okButton","cancelButton","toggleCrop","cropCurrentZone","releaseFocus","on","onMouseDown","onMouseMove","onMouseUp","onObjectMoving","onObjectScaling","addListener","onKeyDown","onKeyUp","hasFocus","currentObject","target","cropZone","x","y","w","h","maxX","maxY","set","preventScaling","pointer","getPointer","e","minX","minY","lastScaleX","setLeft","lastScaleY","setTop","scaleToWidth","scaleToHeight","getScaleX","getScaleY","calcOffset","point","Point","activeObject","getActiveObject","containsPoint","discardActiveObject","onMouseMoveKeyCrop","_renderCropZone","zone","setActiveObject","keyCode","selectZone","forceDimension","requireFocus","bringToFront","originX","originY","cornerColor","cornerSize","transparentCorners","hasRotatingPoint","defaultCursor","fromX","fromY","toX","toY","isRight","isLeft","isDown","isUp","leftX","rightX","topY","bottomY","newWidth","newHeight","Rotation","angle","rotate","renderAll","RotatePlugin","leftButton","rightButton","rotateLeft","rotateRight","SavePlugin","destroyButton","main"],"mappings":"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","file":"../skylark-ui-imager.js","sourcesContent":["define('skylark-ui-imager/Imager',[\n    \"skylark-langx/skylark\",\n    \"skylark-langx/langx\",\n    \"skylark-utils/noder\",\n    \"skylark-utils/finder\",\n    \"skylark-utils/widgets\",\n    \"skylark-utils-canvas2d\",\n], function(skylark, langx, noder,finder,widgets,canvas2d,UI) {\n  'use strict';\n\n  var ui = skylark.ui = skylark.ui || {};\n\n  var Plugins = {};\n\n  function computeImageViewPort(image) {\n    //return {\n    //  height : image.height,\n    //  width : image.width\n    //};\n    return {\n      height: Math.abs(image.getWidth() * (Math.sin(image.getAngle() * Math.PI/180))) + Math.abs(image.getHeight() * (Math.cos(image.getAngle() * Math.PI/180))),\n      width: Math.abs(image.getHeight() * (Math.sin(image.getAngle() * Math.PI/180))) + Math.abs(image.getWidth() * (Math.cos(image.getAngle() * Math.PI/180))),\n    }\n  }\n\n // Toolbar object.\n  function Toolbar(element) {\n    this.element = element;\n  }\n\n  Toolbar.prototype = {\n    createButtonGroup: function(options) {\n      var buttonGroup = document.createElement('div');\n      buttonGroup.className = 'darkroom-button-group';\n      this.element.appendChild(buttonGroup);\n\n      return new ButtonGroup(buttonGroup);\n    }\n  };\n\n  // ButtonGroup object.\n  function ButtonGroup(element) {\n    this.element = element;\n  }\n\n  ButtonGroup.prototype = {\n    createButton: function(options) {\n      var defaults = {\n        image: 'help',\n        type: 'default',\n        group: 'default',\n        hide: false,\n        disabled: false\n      };\n\n      options = langx.mixin({},defaults,options);\n\n      var buttonElement = document.createElement('button');\n      buttonElement.type = 'button';\n      buttonElement.className = 'darkroom-button darkroom-button-' + options.type;\n      buttonElement.innerHTML = '<svg class=\"darkroom-icon\"><use xlink:href=\"#' + options.image + '\" /></svg>';\n      this.element.appendChild(buttonElement);\n\n      var button = new Button(buttonElement);\n      button.hide(options.hide);\n      button.disable(options.disabled);\n\n      return button;\n    }\n  }\n\n  // Button object.\n  function Button(element) {\n    this.element = element;\n  }\n\n  Button.prototype = {\n    addEventListener: function(eventName, listener) {\n      if (this.element.addEventListener){\n        this.element.addEventListener(eventName, listener);\n      } else if (this.element.attachEvent) {\n        this.element.attachEvent('on' + eventName, listener);\n      }\n    },\n    removeEventListener: function(eventName, listener) {\n      if (this.element.removeEventListener){\n        this.element.removeEventListener(eventName, listener);\n      }\n    },\n    active: function(value) {\n      if (value)\n        this.element.classList.add('darkroom-button-active');\n      else\n        this.element.classList.remove('darkroom-button-active');\n    },\n    hide: function(value) {\n      if (value)\n        this.element.classList.add('darkroom-button-hidden');\n      else\n        this.element.classList.remove('darkroom-button-hidden');\n    },\n    disable: function(value) {\n      this.element.disabled = (value) ? true : false;\n    }\n  };\n\n  var Imager = widgets.Widget.inherit({\n    klassName : \"Imager\",\n\n    /*\n     * @param {Element} el The container element. \n     */\n    init : function(el,options,plugins) {\n      if (typeof el === 'string') {\n        el = finder.find(el);\n      }\n\n      this._initializeDOM(el);\n      this.overrided(this.containerElement,options);\n      this.options = langx.mixin({}, this.defaults,options);\n\n      // List of the instancied plugins\n      this.plugins = {};\n\n//      var image = new Image();\n//      image.onload = function() {\n        // Initialize the DOM/canvas2d elements\n        this._initializeImage();\n\n        // Then initialize the plugins\n        this._initializePlugins();\n\n        // Public method to adjust image according to the canvas\n        this.refresh(function() {\n          // Execute a custom callback after initialization\n          this.options.initialize.bind(this).call();\n        }.bind(this));\n\n  //    }.bind(this)\n\n      //image.crossOrigin = 'anonymous';\n      //image.src = el.src;\n    },\n\n    // Reference to the main container element\n    containerElement: null,\n\n    // Reference to the canvas2d canvas object\n    canvas: null,\n\n    // Reference to the canvas2d image object\n    image: null,\n\n    // Reference to the canvas2d source canvas object\n    sourceCanvas: null,\n\n    // Reference to the canvas2d source image object\n    sourceImage: null,\n\n    // Track of the original image element\n    originalImageElement: null,\n\n    // Stack of transformations to apply to the image source\n    transformations: [],\n\n    // Default options\n    defaults: {\n      // Canvas properties (dimension, ratio, color)\n      minWidth: null,\n      minHeight: null,\n      maxWidth: null,\n      maxHeight: null,\n      ratio: null,\n      backgroundColor: '#fff',\n\n      // Plugins options\n      plugins: {},\n\n      // Post-initialisation callback\n      initialize: function() { /* noop */ }\n    },\n\n\n\n    selfDestroy: function() {\n      var container = this.containerElement;\n      var image = new Image();\n      image.onload = function() {\n        container.parentNode.replaceChild(image, container);\n      }\n\n      image.src = this.sourceImage.toDataURL();\n    },\n\n    // Add ability to attach event listener on the core object.\n    // It uses the canvas element to process events.\n    addEventListener: function(eventName, callback) {\n      var el = this.canvas.getElement();\n      if (el.addEventListener){\n        el.addEventListener(eventName, callback);\n      } else if (el.attachEvent) {\n        el.attachEvent('on' + eventName, callback);\n      }\n    },\n\n    dispatchEvent: function(eventName) {\n      // Use the old way of creating event to be IE compatible\n      // See https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events\n      var event = document.createEvent('Event');\n      event.initEvent(eventName, true, true);\n\n      this.canvas.getElement().dispatchEvent(event);\n    },\n\n    // Adjust image & canvas dimension according to min/max width/height\n    // and ratio specified in the options.\n    // This method should be called after each image transformation.\n    refresh: function(next) {\n      var clone = new Image();\n      clone.onload = function() {\n        this._replaceCurrentImage(new canvas2d.Image(clone));\n\n        if (next) next();\n      }.bind(this);\n      clone.src = this.sourceImage.toDataURL();\n    },\n\n    _replaceCurrentImage: function(newImage) {\n      if (this.image) {\n        this.image.remove();\n      }\n\n      this.image = newImage;\n      this.image.selectable = false;\n\n      // Adjust width or height according to specified ratio\n      var viewport = computeImageViewPort(this.image);\n      var canvasWidth = viewport.width;\n      var canvasHeight = viewport.height;\n\n      if (null !== this.options.ratio) {\n        var canvasRatio = +this.options.ratio;\n        var currentRatio = canvasWidth / canvasHeight;\n\n        if (currentRatio > canvasRatio) {\n          canvasHeight = canvasWidth / canvasRatio;\n        } else if (currentRatio < canvasRatio) {\n          canvasWidth = canvasHeight * canvasRatio;\n        }\n      }\n\n      // Then scale the image to fit into dimension limits\n      var scaleMin = 1;\n      var scaleMax = 1;\n      var scaleX = 1;\n      var scaleY = 1;\n\n      if (null !== this.options.maxWidth && this.options.maxWidth < canvasWidth) {\n        scaleX =  this.options.maxWidth / canvasWidth;\n      }\n      if (null !== this.options.maxHeight && this.options.maxHeight < canvasHeight) {\n        scaleY =  this.options.maxHeight / canvasHeight;\n      }\n      scaleMin = Math.min(scaleX, scaleY);\n\n      scaleX = 1;\n      scaleY = 1;\n      if (null !== this.options.minWidth && this.options.minWidth > canvasWidth) {\n        scaleX =  this.options.minWidth / canvasWidth;\n      }\n      if (null !== this.options.minHeight && this.options.minHeight > canvasHeight) {\n        scaleY =  this.options.minHeight / canvasHeight;\n      }\n      scaleMax = Math.max(scaleX, scaleY);\n\n      var scale = scaleMax * scaleMin; // one should be equals to 1\n\n      canvasWidth *= scale;\n      canvasHeight *= scale;\n\n      // Finally place the image in the center of the canvas\n      this.image.setScaleX(1 * scale);\n      this.image.setScaleY(1 * scale);\n      this.canvas.add(this.image);\n      this.canvas.setWidth(canvasWidth);\n      this.canvas.setHeight(canvasHeight);\n      this.canvas.centerObject(this.image);\n      this.image.setCoords();\n    },\n\n    // Apply the transformation on the current image and save it in the\n    // transformations stack (in order to reconstitute the previous states\n    // of the image).\n    applyTransformation: function(transformation) {\n      this.transformations.push(transformation);\n\n      transformation.applyTransformation(\n        this.sourceCanvas,\n        this.sourceImage,\n        this._postTransformation.bind(this)\n      );\n    },\n\n    _postTransformation: function(newImage) {\n      if (newImage)\n        this.sourceImage = newImage;\n\n      this.refresh(function() {\n        this.dispatchEvent('core:transformation');\n      }.bind(this));\n    },\n\n    // Initialize image from original element plus re-apply every\n    // transformations.\n    reinitializeImage: function() {\n      this.sourceImage.remove();\n      this._initializeImage();\n      this._popTransformation(this.transformations.slice())\n    },\n\n    _popTransformation: function(transformations) {\n      if (0 === transformations.length) {\n        this.dispatchEvent('core:reinitialized');\n        this.refresh();\n        return;\n      }\n\n      var transformation = transformations.shift();\n\n      var next = function(newImage) {\n        if (newImage) this.sourceImage = newImage;\n        this._popTransformation(transformations)\n      };\n\n      transformation.applyTransformation(\n        this.sourceCanvas,\n        this.sourceImage,\n        next.bind(this)\n      );\n    },\n\n    // Create the DOM elements and instanciate the canvas2d canvas.\n    // The image element is replaced by a new `div` element.\n    // However the original image is re-injected in order to keep a trace of it.\n    _initializeDOM: function(imageElement) {\n      // Container\n      var mainContainerElement = document.createElement('div');\n      mainContainerElement.className = 'darkroom-container';\n\n      // Toolbar\n      var toolbarElement = document.createElement('div');\n      toolbarElement.className = 'darkroom-toolbar';\n      mainContainerElement.appendChild(toolbarElement);\n\n      // Viewport canvas\n      var canvasContainerElement = document.createElement('div');\n      canvasContainerElement.className = 'darkroom-image-container';\n      var canvasElement = this.canvasElement = document.createElement('canvas');\n      canvasContainerElement.appendChild(canvasElement);\n      mainContainerElement.appendChild(canvasContainerElement);\n\n      // Source canvas\n      var sourceCanvasContainerElement = document.createElement('div');\n      sourceCanvasContainerElement.className = 'darkroom-source-container';\n      sourceCanvasContainerElement.style.display = 'none';\n      var sourceCanvasElement = this.sourceCanvasElement = document.createElement('canvas');\n      sourceCanvasContainerElement.appendChild(sourceCanvasElement);\n      mainContainerElement.appendChild(sourceCanvasContainerElement);\n\n      // Original image\n      imageElement.parentNode.replaceChild(mainContainerElement, imageElement);\n      imageElement.style.display = 'none';\n      mainContainerElement.appendChild(imageElement);\n\n      // Instanciate object from elements\n      this.containerElement = mainContainerElement;\n      this.originalImageElement = imageElement;\n\n      this.toolbar = new Toolbar(toolbarElement);\n\n    },\n\n    // Instanciate the canvas2d image object.\n    // The image is created as a static element with no control,\n    // then it is add in the canvas2d canvas object.\n    _initializeImage: function() {\n      this.canvas = new canvas2d.Canvas(this.canvasElement, {\n        selection: false,\n        backgroundColor: this.options.backgroundColor\n      });\n\n      this.sourceCanvas = new canvas2d.Canvas(this.sourceCanvasElement, {\n        selection: false,\n        backgroundColor: this.options.backgroundColor\n      });\n \n      this.sourceImage = new canvas2d.Image(this.originalImageElement, {\n        // Some options to make the image static\n        selectable: false,\n        evented: false,\n        lockMovementX: true,\n        lockMovementY: true,\n        lockRotation: true,\n        lockScalingX: true,\n        lockScalingY: true,\n        lockUniScaling: true,\n        hasControls: false,\n        hasBorders: false,\n      });\n\n      this.sourceCanvas.add(this.sourceImage);\n\n      // Adjust width or height according to specified ratio\n      var viewport = computeImageViewPort(this.sourceImage);\n      var canvasWidth = viewport.width;\n      var canvasHeight = viewport.height;\n\n      this.sourceCanvas.setWidth(canvasWidth);\n      this.sourceCanvas.setHeight(canvasHeight);\n      this.sourceCanvas.centerObject(this.sourceImage);\n      this.sourceImage.setCoords();\n    },\n\n    // Initialize every plugins.\n    // Note that plugins are instanciated in the same order than they\n    // are declared in the parameter object.\n    _initializePlugins: function() {\n      for (var name in Plugins) {\n        var pluginInfo = Plugins[name];\n        var options = this.options.plugins[name];\n\n        // Setting false into the plugin options will disable the plugin\n        if (options === false)\n          continue;\n\n        // Avoid any issues with _proto_\n        if (!Plugins.hasOwnProperty(name))\n          continue;\n\n        this.plugins[name] = new pluginInfo.ctor(this, options);\n      }\n    }\n\n  });\n\n\n  Imager.Plugin = langx.Evented.inherit({\n    klassName : \"Plugin\",\n\n    defaults: {},\n\n    init : function(imager,options) {\n      this.imager = imager;\n      this.options = langx.mixin({},this.defaults,options);\n\n    }\n  });\n\n\n  Imager.Transformation = langx.Evented.inherit({\n    klassName : \"Transformation\",\n\n    init : function(options) {\n      this.options = options;\n    }\n  });\n\n\n  Imager.installPlugin = function(setting) {\n\n    //Plugins.push(setting);\n    Plugins[setting.name] = setting;\n  };\n\n  return ui.Imager = Imager;\n\n});\n\n\ndefine('skylark-ui-imager/plugins/history',[\n  \"skylark-langx/langx\",\n  \"skylark-utils/noder\",\n  \"skylark-utils/query\",\n  \"skylark-utils-canvas2d\",\n  '../Imager',\n],function(langx,noder, $, canvas2d,Imager) {\n  'use strict';\n\n  var HistoryPlugin= Imager.Plugin.inherit({\n     undoTransformations: null,\n\n     init : function(imager,options) {\n      this.overrided(imager,options);\n      this.undoTransformations = [];\n      this._initButtons();\n\n      this.imager.addEventListener('core:transformation', this._onTranformationApplied.bind(this));\n    },\n\n    undo: function() {\n      if (this.imager.transformations.length === 0) {\n        return;\n      }\n\n      var lastTransformation = this.imager.transformations.pop();\n      this.undoTransformations.unshift(lastTransformation);\n\n      this.imager.reinitializeImage();\n      this._updateButtons();\n    },\n\n    redo: function() {\n      if (this.undoTransformations.length === 0) {\n        return;\n      }\n\n      var cancelTransformation = this.undoTransformations.shift();\n      this.imager.transformations.push(cancelTransformation);\n\n      this.imager.reinitializeImage();\n      this._updateButtons();\n    },\n\n    _initButtons: function() {\n      var buttonGroup = this.imager.toolbar.createButtonGroup();\n\n      this.backButton = buttonGroup.createButton({\n        image: 'undo',\n        disabled: true\n      });\n\n      this.forwardButton = buttonGroup.createButton({\n        image: 'redo',\n        disabled: true\n      });\n\n      this.backButton.addEventListener('click', this.undo.bind(this));\n      this.forwardButton.addEventListener('click', this.redo.bind(this));\n\n      return this;\n    },\n\n    _updateButtons: function() {\n      this.backButton.disable((this.imager.transformations.length === 0))\n      this.forwardButton.disable((this.undoTransformations.length === 0))\n    },\n\n    _onTranformationApplied: function() {\n      this.undoTransformations = [];\n      this._updateButtons();\n    }\n  });\n\n  var pluginInfo = {\n    name : \"history\",\n    ctor : HistoryPlugin\n  };\n\n  Imager.installPlugin(pluginInfo);\n\n  return pluginInfo;\n\n  \n});\n\ndefine('skylark-ui-imager/plugins/crop',[\n  \"skylark-langx/langx\",\n  \"skylark-utils/noder\",\n  \"skylark-utils/images\",\n  \"skylark-utils/query\",\n  \"skylark-utils-canvas2d\",\n  '../Imager',\n],function(langx,noder, images,$, canvas2d,Imager) {\n  'use strict';\n\n  function computeImageViewPort(image) {\n    //return {\n    //  height : image.height,\n    //  width : image.width\n    //};\n    return {\n      height: Math.abs(image.getWidth() * (Math.sin(image.getAngle() * Math.PI/180))) + Math.abs(image.getHeight() * (Math.cos(image.getAngle() * Math.PI/180))),\n      width: Math.abs(image.getHeight() * (Math.sin(image.getAngle() * Math.PI/180))) + Math.abs(image.getWidth() * (Math.cos(image.getAngle() * Math.PI/180))),\n    }\n  }\n  \n\n  var Crop = Imager.Transformation.inherit({\n    applyTransformation: function(canvas, image, next) {\n      // Snapshot the image delimited by the crop zone\n      var snapshot = new Image();\n\n      var viewport = computeImageViewPort(image);\n      var imageWidth = viewport.width;\n      var imageHeight = viewport.height;\n\n      var left = this.options.left * imageWidth;\n      var top = this.options.top * imageHeight;\n      var width = Math.min(this.options.width * imageWidth, imageWidth - left);\n      var height = Math.min(this.options.height * imageHeight, imageHeight - top);\n\n      snapshot.src = canvas.toDataURL({\n        left: left,\n        top: top,\n        width: width,\n        height: height,\n      });\n\n      images.loaded(snapshot).then(function() {\n        // Validate image\n        if (height < 1 || width < 1)\n          return;\n\n        var imgInstance = new canvas2d.Image(snapshot, {\n          // options to make the image static\n          selectable: false,\n          evented: false,\n          lockMovementX: true,\n          lockMovementY: true,\n          lockRotation: true,\n          lockScalingX: true,\n          lockScalingY: true,\n          lockUniScaling: true,\n          hasControls: false,\n          hasBorders: false\n        });\n\n        var width = snapshot.width;\n        var height = snapshot.height;\n\n        // Update canvas size\n        canvas.setWidth(width);\n        canvas.setHeight(height);\n\n        // Add image\n        image.remove();\n        canvas.add(imgInstance);\n\n        next(imgInstance);\n      });\n    }\n  });\n\n  var CropZone = canvas2d.util.createClass(canvas2d.Rect, {\n    _render: function(ctx) {\n      this.callSuper('_render', ctx);\n\n      var canvas = ctx.canvas;\n      var dashWidth = 7;\n\n      // Set original scale\n      var flipX = this.flipX ? -1 : 1;\n      var flipY = this.flipY ? -1 : 1;\n      var scaleX = flipX / this.scaleX;\n      var scaleY = flipY / this.scaleY;\n\n      ctx.scale(scaleX, scaleY);\n\n      // Overlay rendering\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n      this._renderOverlay(ctx);\n\n      // Set dashed borders\n      if (ctx.setLineDash !== undefined)\n        ctx.setLineDash([dashWidth, dashWidth]);\n      else if (ctx.mozDash !== undefined)\n        ctx.mozDash = [dashWidth, dashWidth];\n\n      // First lines rendering with black\n      ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';\n      this._renderBorders(ctx);\n      this._renderGrid(ctx);\n\n      // Re render lines in white\n      ctx.lineDashOffset = dashWidth;\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n      this._renderBorders(ctx);\n      this._renderGrid(ctx);\n\n      // Reset scale\n      ctx.scale(1/scaleX, 1/scaleY);\n    },\n\n    _renderOverlay: function(ctx) {\n      var canvas = ctx.canvas;\n\n      //\n      //    x0    x1        x2      x3\n      // y0 +------------------------+\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\n      // y1 +------+---------+-------+\n      //    |\\\\\\\\\\\\|         |\\\\\\\\\\\\\\|\n      //    |\\\\\\\\\\\\|    0    |\\\\\\\\\\\\\\|\n      //    |\\\\\\\\\\\\|         |\\\\\\\\\\\\\\|\n      // y2 +------+---------+-------+\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\n      // y3 +------------------------+\n      //\n\n      var x0 = Math.ceil(-this.getWidth() / 2 - this.getLeft());\n      var x1 = Math.ceil(-this.getWidth() / 2);\n      var x2 = Math.ceil(this.getWidth() / 2);\n      var x3 = Math.ceil(this.getWidth() / 2 + (canvas.width - this.getWidth() - this.getLeft()));\n\n      var y0 = Math.ceil(-this.getHeight() / 2 - this.getTop());\n      var y1 = Math.ceil(-this.getHeight() / 2);\n      var y2 = Math.ceil(this.getHeight() / 2);\n      var y3 = Math.ceil(this.getHeight() / 2 + (canvas.height - this.getHeight() - this.getTop()));\n\n      ctx.beginPath();\n      \n      // Draw outer rectangle.\n      // Numbers are +/-1 so that overlay edges don't get blurry.\n      ctx.moveTo(x0 - 1, y0 - 1);\n      ctx.lineTo(x3 + 1, y0 - 1);\n      ctx.lineTo(x3 + 1, y3 + 1);\n      ctx.lineTo(x0 - 1, y3 - 1);\n      ctx.lineTo(x0 - 1, y0 - 1);\n      ctx.closePath();\n\n      // Draw inner rectangle.\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x1, y2);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x1, y1);\n\n      ctx.closePath();\n      ctx.fill();\n    },\n\n    _renderBorders: function(ctx) {\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2, -this.getHeight()/2); // upper left\n      ctx.lineTo(this.getWidth()/2, -this.getHeight()/2); // upper right\n      ctx.lineTo(this.getWidth()/2, this.getHeight()/2); // down right\n      ctx.lineTo(-this.getWidth()/2, this.getHeight()/2); // down left\n      ctx.lineTo(-this.getWidth()/2, -this.getHeight()/2); // upper left\n      ctx.stroke();\n    },\n\n    _renderGrid: function(ctx) {\n      return;\n      // Vertical lines\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2 + 1/3 * this.getWidth(), -this.getHeight()/2);\n      ctx.lineTo(-this.getWidth()/2 + 1/3 * this.getWidth(), this.getHeight()/2);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2 + 2/3 * this.getWidth(), -this.getHeight()/2);\n      ctx.lineTo(-this.getWidth()/2 + 2/3 * this.getWidth(), this.getHeight()/2);\n      ctx.stroke();\n      // Horizontal lines\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2, -this.getHeight()/2 + 1/3 * this.getHeight());\n      ctx.lineTo(this.getWidth()/2, -this.getHeight()/2 + 1/3 * this.getHeight());\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2, -this.getHeight()/2 + 2/3 * this.getHeight());\n      ctx.lineTo(this.getWidth()/2, -this.getHeight()/2 + 2/3 * this.getHeight());\n      ctx.stroke();\n    }\n  });\n\n  var CropPlugin = Imager.Plugin.inherit({\n    // Init point\n    startX: null,\n    startY: null,\n\n    // Keycrop\n    isKeyCroping: false,\n    isKeyLeft: false,\n    isKeyUp: false,\n\n    defaults: {\n      // min crop dimension\n      minHeight: 1,\n      minWidth: 1,\n      // ensure crop ratio\n      ratio: null,\n      // quick crop feature (set a key code to enable it)\n      quickCropKey: false\n    },\n\n     init : function(imager,options) {\n      this.overrided(imager,options);\n      var buttonGroup = this.imager.toolbar.createButtonGroup();\n\n      this.cropButton = buttonGroup.createButton({\n        image: 'crop'\n      });\n      this.okButton = buttonGroup.createButton({\n        image: 'done',\n        type: 'success',\n        hide: true\n      });\n      this.cancelButton = buttonGroup.createButton({\n        image: 'close',\n        type: 'danger',\n        hide: true\n      });\n\n      // Buttons click\n      this.cropButton.addEventListener('click', this.toggleCrop.bind(this));\n      this.okButton.addEventListener('click', this.cropCurrentZone.bind(this));\n      this.cancelButton.addEventListener('click', this.releaseFocus.bind(this));\n\n      // Canvas events\n      this.imager.canvas.on('mouse:down', this.onMouseDown.bind(this));\n      this.imager.canvas.on('mouse:move', this.onMouseMove.bind(this));\n      this.imager.canvas.on('mouse:up', this.onMouseUp.bind(this));\n      this.imager.canvas.on('object:moving', this.onObjectMoving.bind(this));\n      this.imager.canvas.on('object:scaling', this.onObjectScaling.bind(this));\n\n      canvas2d.util.addListener(document, 'keydown', this.onKeyDown.bind(this));\n      canvas2d.util.addListener(document, 'keyup', this.onKeyUp.bind(this));\n\n      this.imager.addEventListener('core:transformation', this.releaseFocus.bind(this));\n    },\n\n    // Avoid crop zone to go beyond the canvas edges\n    onObjectMoving: function(event) {\n      if (!this.hasFocus()) {\n        return;\n      }\n\n      var currentObject = event.target;\n      if (currentObject !== this.cropZone)\n        return;\n\n      var canvas = this.imager.canvas;\n      var x = currentObject.getLeft(), y = currentObject.getTop();\n      var w = currentObject.getWidth(), h = currentObject.getHeight();\n      var maxX = canvas.getWidth() - w;\n      var maxY = canvas.getHeight() - h;\n\n      if (x < 0)\n        currentObject.set('left', 0);\n      if (y < 0)\n        currentObject.set('top', 0);\n      if (x > maxX)\n        currentObject.set('left', maxX);\n      if (y > maxY)\n        currentObject.set('top', maxY);\n\n      this.imager.dispatchEvent('crop:update');\n    },\n\n    // Prevent crop zone from going beyond the canvas edges (like mouseMove)\n    onObjectScaling: function(event) {\n      if (!this.hasFocus()) {\n        return;\n      }\n\n      var preventScaling = false;\n      var currentObject = event.target;\n      if (currentObject !== this.cropZone)\n        return;\n\n      var canvas = this.imager.canvas;\n      var pointer = canvas.getPointer(event.e);\n      var x = pointer.x;\n      var y = pointer.y;\n\n      var minX = currentObject.getLeft();\n      var minY = currentObject.getTop();\n      var maxX = currentObject.getLeft() + currentObject.getWidth();\n      var maxY = currentObject.getTop() + currentObject.getHeight();\n\n      if (null !== this.options.ratio) {\n        if (minX < 0 || maxX > canvas.getWidth() || minY < 0 || maxY > canvas.getHeight()) {\n          preventScaling = true;\n        }\n      }\n\n      if (minX < 0 || maxX > canvas.getWidth() || preventScaling) {\n        var lastScaleX = this.lastScaleX || 1;\n        currentObject.setScaleX(lastScaleX);\n      }\n      if (minX < 0) {\n        currentObject.setLeft(0);\n      }\n\n      if (minY < 0 || maxY > canvas.getHeight() || preventScaling) {\n        var lastScaleY = this.lastScaleY || 1;\n        currentObject.setScaleY(lastScaleY);\n      }\n      if (minY < 0) {\n        currentObject.setTop(0);\n      }\n\n      if (currentObject.getWidth() < this.options.minWidth) {\n        currentObject.scaleToWidth(this.options.minWidth);\n      }\n      if (currentObject.getHeight() < this.options.minHeight) {\n        currentObject.scaleToHeight(this.options.minHeight);\n      }\n\n      this.lastScaleX = currentObject.getScaleX();\n      this.lastScaleY = currentObject.getScaleY();\n\n      this.imager.dispatchEvent('crop:update');\n    },\n\n    // Init crop zone\n    onMouseDown: function(event) {\n      if (!this.hasFocus()) {\n        return;\n      }\n\n      var canvas = this.imager.canvas;\n\n      // recalculate offset, in case canvas was manipulated since last `calcOffset`\n      canvas.calcOffset();\n      var pointer = canvas.getPointer(event.e);\n      var x = pointer.x;\n      var y = pointer.y;\n      var point = new canvas2d.Point(x, y);\n\n      // Check if user want to scale or drag the crop zone.\n      var activeObject = canvas.getActiveObject();\n      if (activeObject === this.cropZone || this.cropZone.containsPoint(point)) {\n        return;\n      }\n\n      canvas.discardActiveObject();\n      this.cropZone.setWidth(0);\n      this.cropZone.setHeight(0);\n      this.cropZone.setScaleX(1);\n      this.cropZone.setScaleY(1);\n\n      this.startX = x;\n      this.startY = y;\n    },\n\n    // Extend crop zone\n    onMouseMove: function(event) {\n      // Quick crop feature\n      if (this.isKeyCroping)\n        return this.onMouseMoveKeyCrop(event);\n\n      if (null === this.startX || null === this.startY) {\n        return;\n      }\n\n      var canvas = this.imager.canvas;\n      var pointer = canvas.getPointer(event.e);\n      var x = pointer.x;\n      var y = pointer.y;\n\n      this._renderCropZone(this.startX, this.startY, x, y);\n    },\n\n    onMouseMoveKeyCrop: function(event) {\n      var canvas = this.imager.canvas;\n      var zone = this.cropZone;\n\n      var pointer = canvas.getPointer(event.e);\n      var x = pointer.x;\n      var y = pointer.y;\n\n      if (!zone.left || !zone.top) {\n        zone.setTop(y);\n        zone.setLeft(x);\n      }\n\n      this.isKeyLeft =  x < zone.left + zone.width / 2 ;\n      this.isKeyUp = y < zone.top + zone.height / 2 ;\n\n      this._renderCropZone(\n        Math.min(zone.left, x),\n        Math.min(zone.top, y),\n        Math.max(zone.left+zone.width, x),\n        Math.max(zone.top+zone.height, y)\n      );\n    },\n\n    // Finish crop zone\n    onMouseUp: function(event) {\n      if (null === this.startX || null === this.startY) {\n        return;\n      }\n\n      var canvas = this.imager.canvas;\n      this.cropZone.setCoords();\n      canvas.setActiveObject(this.cropZone);\n      canvas.calcOffset();\n\n      this.startX = null;\n      this.startY = null;\n    },\n\n    onKeyDown: function(event) {\n      if (false === this.options.quickCropKey || event.keyCode !== this.options.quickCropKey || this.isKeyCroping)\n        return;\n\n      // Active quick crop flow\n      this.isKeyCroping = true ;\n      this.imager.canvas.discardActiveObject();\n      this.cropZone.setWidth(0);\n      this.cropZone.setHeight(0);\n      this.cropZone.setScaleX(1);\n      this.cropZone.setScaleY(1);\n      this.cropZone.setTop(0);\n      this.cropZone.setLeft(0);\n    },\n\n    onKeyUp: function(event) {\n      if (false === this.options.quickCropKey || event.keyCode !== this.options.quickCropKey || !this.isKeyCroping)\n        return;\n\n      // Unactive quick crop flow\n      this.isKeyCroping = false;\n      this.startX = 1;\n      this.startY = 1;\n      this.onMouseUp();\n    },\n\n    selectZone: function(x, y, width, height, forceDimension) {\n      if (!this.hasFocus())\n        this.requireFocus();\n\n      if (!forceDimension) {\n        this._renderCropZone(x, y, x+width, y+height);\n      } else {\n        this.cropZone.set({\n          'left': x,\n          'top': y,\n          'width': width,\n          'height': height\n        });\n      }\n\n      var canvas = this.imager.canvas;\n      canvas.bringToFront(this.cropZone);\n      this.cropZone.setCoords();\n      canvas.setActiveObject(this.cropZone);\n      canvas.calcOffset();\n\n      this.imager.dispatchEvent('crop:update');\n    },\n\n    toggleCrop: function() {\n      if (!this.hasFocus())\n        this.requireFocus();\n      else\n        this.releaseFocus();\n    },\n\n    cropCurrentZone: function() {\n      if (!this.hasFocus())\n        return;\n\n      // Avoid croping empty zone\n      if (this.cropZone.width < 1 && this.cropZone.height < 1)\n        return;\n\n      var image = this.imager.image;\n\n      // Compute crop zone dimensions\n      var top = this.cropZone.getTop() - image.getTop();\n      var left = this.cropZone.getLeft() - image.getLeft();\n      var width = this.cropZone.getWidth();\n      var height = this.cropZone.getHeight();\n\n      // Adjust dimensions to image only\n      if (top < 0) {\n        height += top;\n        top = 0;\n      }\n\n      if (left < 0) {\n        width += left;\n        left = 0;\n      }\n\n      // Apply crop transformation.\n      // Make sure to use relative dimension since the crop will be applied\n      // on the source image.\n      this.imager.applyTransformation(new Crop({\n        top: top / image.getHeight(),\n        left: left / image.getWidth(),\n        width: width / image.getWidth(),\n        height: height / image.getHeight(),\n      }));\n    },\n\n    // Test wether crop zone is set\n    hasFocus: function() {\n      return this.cropZone !== undefined;\n    },\n\n    // Create the crop zone\n    requireFocus: function() {\n      this.cropZone = new CropZone({\n        fill: 'transparent',\n        hasBorders: false,\n        originX: 'left',\n        originY: 'top',\n        //stroke: '#444',\n        //strokeDashArray: [5, 5],\n        //borderColor: '#444',\n        cornerColor: '#444',\n        cornerSize: 8,\n        transparentCorners: false,\n        lockRotation: true,\n        hasRotatingPoint: false,\n      });\n\n      if (null !== this.options.ratio) {\n        this.cropZone.set('lockUniScaling', true);\n      }\n\n      this.imager.canvas.add(this.cropZone);\n      this.imager.canvas.defaultCursor = 'crosshair';\n\n      this.cropButton.active(true);\n      this.okButton.hide(false);\n      this.cancelButton.hide(false);\n    },\n\n    // Remove the crop zone\n    releaseFocus: function() {\n      if (undefined === this.cropZone)\n        return;\n\n      this.cropZone.remove();\n      this.cropZone = undefined;\n\n      this.cropButton.active(false);\n      this.okButton.hide(true);\n      this.cancelButton.hide(true);\n\n      this.imager.canvas.defaultCursor = 'default';\n\n      this.imager.dispatchEvent('crop:update');\n    },\n\n    _renderCropZone: function(fromX, fromY, toX, toY) {\n      var canvas = this.imager.canvas;\n\n      var isRight = (toX > fromX);\n      var isLeft = !isRight;\n      var isDown = (toY > fromY);\n      var isUp = !isDown;\n\n      var minWidth = Math.min(+this.options.minWidth, canvas.getWidth());\n      var minHeight = Math.min(+this.options.minHeight, canvas.getHeight());\n\n      // Define corner coordinates\n      var leftX = Math.min(fromX, toX);\n      var rightX = Math.max(fromX, toX);\n      var topY = Math.min(fromY, toY);\n      var bottomY = Math.max(fromY, toY);\n\n      // Replace current point into the canvas\n      leftX = Math.max(0, leftX);\n      rightX = Math.min(canvas.getWidth(), rightX);\n      topY = Math.max(0, topY)\n      bottomY = Math.min(canvas.getHeight(), bottomY);\n\n      // Recalibrate coordinates according to given options\n      if (rightX - leftX < minWidth) {\n        if (isRight)\n          rightX = leftX + minWidth;\n        else\n          leftX = rightX - minWidth;\n      }\n      if (bottomY - topY < minHeight) {\n        if (isDown)\n          bottomY = topY + minHeight;\n        else\n          topY = bottomY - minHeight;\n      }\n\n      // Truncate truncate according to canvas dimensions\n      if (leftX < 0) {\n        // Translate to the left\n        rightX += Math.abs(leftX);\n        leftX = 0\n      }\n      if (rightX > canvas.getWidth()) {\n        // Translate to the right\n        leftX -= (rightX - canvas.getWidth());\n        rightX = canvas.getWidth();\n      }\n      if (topY < 0) {\n        // Translate to the bottom\n        bottomY += Math.abs(topY);\n        topY = 0\n      }\n      if (bottomY > canvas.getHeight()) {\n        // Translate to the right\n        topY -= (bottomY - canvas.getHeight());\n        bottomY = canvas.getHeight();\n      }\n\n      var width = rightX - leftX;\n      var height = bottomY - topY;\n      var currentRatio = width / height;\n\n      if (this.options.ratio && +this.options.ratio !== currentRatio) {\n        var ratio = +this.options.ratio;\n\n        if(this.isKeyCroping) {\n          isLeft = this.isKeyLeft;\n          isUp = this.isKeyUp;\n        }\n\n        if (currentRatio < ratio) {\n          var newWidth = height * ratio;\n          if (isLeft) {\n            leftX -= (newWidth - width);\n          }\n          width = newWidth;\n        } else if (currentRatio > ratio) {\n          var newHeight = height / (ratio * height/width);\n          if (isUp) {\n            topY -= (newHeight - height);\n          }\n          height = newHeight;\n        }\n\n        if (leftX < 0) {\n          leftX = 0;\n          //TODO\n        }\n        if (topY < 0) {\n          topY = 0;\n          //TODO\n        }\n        if (leftX + width > canvas.getWidth()) {\n          var newWidth = canvas.getWidth() - leftX;\n          height = newWidth * height / width;\n          width = newWidth;\n          if (isUp) {\n            topY = fromY - height;\n          }\n        }\n        if (topY + height > canvas.getHeight()) {\n          var newHeight = canvas.getHeight() - topY;\n          width = width * newHeight / height;\n          height = newHeight;\n          if (isLeft) {\n            leftX = fromX - width;\n          }\n        }\n      }\n\n      // Apply coordinates\n      this.cropZone.left = leftX;\n      this.cropZone.top = topY;\n      this.cropZone.width = width;\n      this.cropZone.height = height;\n\n      this.imager.canvas.bringToFront(this.cropZone);\n\n      this.imager.dispatchEvent('crop:update');\n    }\n  });\n\n  var pluginInfo = {\n    name : \"crop\",\n    ctor : CropPlugin\n  };\n\n  Imager.installPlugin(pluginInfo);\n\n  return pluginInfo;\n\n});\n\ndefine('skylark-ui-imager/plugins/rotate',[\n  \"skylark-langx/langx\",\n  \"skylark-utils/noder\",\n  \"skylark-utils/query\",\n  \"skylark-utils-canvas2d\",\n  '../Imager',\n],function(langx,noder, $, canvas2d,Imager) {\n  'use strict';\n\nvar Rotation = Imager.Transformation.inherit({\n\n  applyTransformation: function(canvas, image, next) {\n    var angle = (image.getAngle() + this.options.angle) % 360;\n    image.rotate(angle);\n\n    var width, height;\n    height = Math.abs(image.getWidth()*(Math.sin(angle*Math.PI/180)))+Math.abs(image.getHeight()*(Math.cos(angle*Math.PI/180)));\n    width = Math.abs(image.getHeight()*(Math.sin(angle*Math.PI/180)))+Math.abs(image.getWidth()*(Math.cos(angle*Math.PI/180)));\n\n    canvas.setWidth(width);\n    canvas.setHeight(height);\n\n    canvas.centerObject(image);\n    image.setCoords();\n    canvas.renderAll();\n\n    next();\n  }\n});\n\n\n  var RotatePlugin = Imager.Plugin.inherit({\n    init: function(imager,options) {\n      this.overrided(imager,options);\n      var buttonGroup = this.imager.toolbar.createButtonGroup();\n\n      var leftButton = buttonGroup.createButton({\n        image: 'rotate-left'\n      });\n\n      var rightButton = buttonGroup.createButton({\n        image: 'rotate-right'\n      });\n\n      leftButton.addEventListener('click', this.rotateLeft.bind(this));\n      rightButton.addEventListener('click', this.rotateRight.bind(this));\n    },\n\n    rotateLeft: function() {\n      this.rotate(-90);\n    },\n\n    rotateRight: function() {\n      this.rotate(90);\n    },\n\n    rotate: function rotate(angle) {\n      this.imager.applyTransformation(\n        new Rotation({angle: angle})\n      );\n    }\n  });\n\n  var pluginInfo = {\n    name : \"rotate\",\n    ctor : RotatePlugin\n  };\n\n  Imager.installPlugin(pluginInfo);\n\n  return pluginInfo;\n\n});\n\ndefine('skylark-ui-imager/plugins/save',[\n  \"skylark-langx/langx\",\n  \"skylark-utils/noder\",\n  \"skylark-utils/query\",\n  \"skylark-utils-canvas2d\",\n  '../Imager',\n],function(langx,noder, $, canvas2d,Imager) {\n  'use strict';\n\n  var SavePlugin= Imager.Plugin.inherit({\n\n    defaults: {\n      callback: function() {\n        this.imager.selfDestroy();\n      }\n    },\n\n    init: function(imager,options) {\n      this.overrided(imager,options);\n\n      var buttonGroup = this.imager.toolbar.createButtonGroup();\n\n      this.destroyButton = buttonGroup.createButton({\n        image: 'save'\n      });\n\n      this.destroyButton.addEventListener('click', this.options.callback.bind(this));\n    },\n  });\n\n  var pluginInfo = {\n    name : \"save\",\n    ctor : SavePlugin\n  };\n\n  Imager.installPlugin(pluginInfo);\n\n  return pluginInfo;  \n\n});\n\ndefine('skylark-ui-imager/main',[\r\n    \"./Imager\",\r\n    \"./plugins/history\",\r\n    \"./plugins/crop\",\r\n    \"./plugins/rotate\",\r\n    \"./plugins/save\"\r\n], function(Imager) {\r\n    return Imager;\r\n})\r\n;\ndefine('skylark-ui-imager', ['skylark-ui-imager/main'], function (main) { return main; });\n\n"]}