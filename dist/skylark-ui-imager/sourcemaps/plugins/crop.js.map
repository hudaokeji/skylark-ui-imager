{"version":3,"sources":["plugins/crop.js"],"names":["define","langx","noder","images","$","canvas2d","Imager","computeImageViewPort","image","height","Math","abs","getWidth","sin","getAngle","PI","getHeight","cos","width","Crop","Transformation","inherit","applyTransformation","canvas","next","snapshot","Image","viewport","imageWidth","imageHeight","left","this","options","top","min","src","toDataURL","loaded","then","imgInstance","selectable","evented","lockMovementX","lockMovementY","lockRotation","lockScalingX","lockScalingY","lockUniScaling","hasControls","hasBorders","setWidth","setHeight","remove","add","CropZone","util","createClass","Rect","_render","ctx","callSuper","dashWidth","flipX","flipY","scaleX","scaleY","scale","fillStyle","_renderOverlay","undefined","setLineDash","mozDash","strokeStyle","_renderBorders","_renderGrid","lineDashOffset","x0","ceil","getLeft","x1","x2","x3","y0","getTop","y1","y2","y3","beginPath","moveTo","lineTo","closePath","fill","stroke","CropPlugin","Plugin","startX","startY","isKeyCroping","isKeyLeft","isKeyUp","defaults","minHeight","minWidth","ratio","quickCropKey","init","imager","overrided","buttonGroup","toolbar","createButtonGroup","cropButton","createButton","okButton","type","hide","cancelButton","addEventListener","toggleCrop","bind","cropCurrentZone","releaseFocus","on","onMouseDown","onMouseMove","onMouseUp","onObjectMoving","onObjectScaling","addListener","document","onKeyDown","onKeyUp","event","hasFocus","currentObject","target","cropZone","x","y","w","h","maxX","maxY","set","dispatchEvent","preventScaling","pointer","getPointer","e","minX","minY","lastScaleX","setScaleX","setLeft","lastScaleY","setScaleY","setTop","scaleToWidth","scaleToHeight","getScaleX","getScaleY","calcOffset","point","Point","activeObject","getActiveObject","containsPoint","discardActiveObject","onMouseMoveKeyCrop","_renderCropZone","zone","max","setCoords","setActiveObject","keyCode","selectZone","forceDimension","requireFocus","bringToFront","originX","originY","cornerColor","cornerSize","transparentCorners","hasRotatingPoint","defaultCursor","active","fromX","fromY","toX","toY","isRight","isLeft","isDown","isUp","leftX","rightX","topY","bottomY","currentRatio","newWidth","newHeight","pluginInfo","name","ctor","installPlugin"],"mappings":"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","file":"../../plugins/crop.js","sourcesContent":["define([\n  \"skylark-langx/langx\",\n  \"skylark-utils/noder\",\n  \"skylark-utils/images\",\n  \"skylark-utils/query\",\n  \"skylark-utils-canvas2d\",\n  '../Imager',\n],function(langx,noder, images,$, canvas2d,Imager) {\n  'use strict';\n\n  function computeImageViewPort(image) {\n    //return {\n    //  height : image.height,\n    //  width : image.width\n    //};\n    return {\n      height: Math.abs(image.getWidth() * (Math.sin(image.getAngle() * Math.PI/180))) + Math.abs(image.getHeight() * (Math.cos(image.getAngle() * Math.PI/180))),\n      width: Math.abs(image.getHeight() * (Math.sin(image.getAngle() * Math.PI/180))) + Math.abs(image.getWidth() * (Math.cos(image.getAngle() * Math.PI/180))),\n    }\n  }\n  \n\n  var Crop = Imager.Transformation.inherit({\n    applyTransformation: function(canvas, image, next) {\n      // Snapshot the image delimited by the crop zone\n      var snapshot = new Image();\n\n      var viewport = computeImageViewPort(image);\n      var imageWidth = viewport.width;\n      var imageHeight = viewport.height;\n\n      var left = this.options.left * imageWidth;\n      var top = this.options.top * imageHeight;\n      var width = Math.min(this.options.width * imageWidth, imageWidth - left);\n      var height = Math.min(this.options.height * imageHeight, imageHeight - top);\n\n      snapshot.src = canvas.toDataURL({\n        left: left,\n        top: top,\n        width: width,\n        height: height,\n      });\n\n      images.loaded(snapshot).then(function() {\n        // Validate image\n        if (height < 1 || width < 1)\n          return;\n\n        var imgInstance = new canvas2d.Image(snapshot, {\n          // options to make the image static\n          selectable: false,\n          evented: false,\n          lockMovementX: true,\n          lockMovementY: true,\n          lockRotation: true,\n          lockScalingX: true,\n          lockScalingY: true,\n          lockUniScaling: true,\n          hasControls: false,\n          hasBorders: false\n        });\n\n        var width = snapshot.width;\n        var height = snapshot.height;\n\n        // Update canvas size\n        canvas.setWidth(width);\n        canvas.setHeight(height);\n\n        // Add image\n        image.remove();\n        canvas.add(imgInstance);\n\n        next(imgInstance);\n      });\n    }\n  });\n\n  var CropZone = canvas2d.util.createClass(canvas2d.Rect, {\n    _render: function(ctx) {\n      this.callSuper('_render', ctx);\n\n      var canvas = ctx.canvas;\n      var dashWidth = 7;\n\n      // Set original scale\n      var flipX = this.flipX ? -1 : 1;\n      var flipY = this.flipY ? -1 : 1;\n      var scaleX = flipX / this.scaleX;\n      var scaleY = flipY / this.scaleY;\n\n      ctx.scale(scaleX, scaleY);\n\n      // Overlay rendering\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n      this._renderOverlay(ctx);\n\n      // Set dashed borders\n      if (ctx.setLineDash !== undefined)\n        ctx.setLineDash([dashWidth, dashWidth]);\n      else if (ctx.mozDash !== undefined)\n        ctx.mozDash = [dashWidth, dashWidth];\n\n      // First lines rendering with black\n      ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';\n      this._renderBorders(ctx);\n      this._renderGrid(ctx);\n\n      // Re render lines in white\n      ctx.lineDashOffset = dashWidth;\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n      this._renderBorders(ctx);\n      this._renderGrid(ctx);\n\n      // Reset scale\n      ctx.scale(1/scaleX, 1/scaleY);\n    },\n\n    _renderOverlay: function(ctx) {\n      var canvas = ctx.canvas;\n\n      //\n      //    x0    x1        x2      x3\n      // y0 +------------------------+\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\n      // y1 +------+---------+-------+\n      //    |\\\\\\\\\\\\|         |\\\\\\\\\\\\\\|\n      //    |\\\\\\\\\\\\|    0    |\\\\\\\\\\\\\\|\n      //    |\\\\\\\\\\\\|         |\\\\\\\\\\\\\\|\n      // y2 +------+---------+-------+\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\n      //    |\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\n      // y3 +------------------------+\n      //\n\n      var x0 = Math.ceil(-this.getWidth() / 2 - this.getLeft());\n      var x1 = Math.ceil(-this.getWidth() / 2);\n      var x2 = Math.ceil(this.getWidth() / 2);\n      var x3 = Math.ceil(this.getWidth() / 2 + (canvas.width - this.getWidth() - this.getLeft()));\n\n      var y0 = Math.ceil(-this.getHeight() / 2 - this.getTop());\n      var y1 = Math.ceil(-this.getHeight() / 2);\n      var y2 = Math.ceil(this.getHeight() / 2);\n      var y3 = Math.ceil(this.getHeight() / 2 + (canvas.height - this.getHeight() - this.getTop()));\n\n      ctx.beginPath();\n      \n      // Draw outer rectangle.\n      // Numbers are +/-1 so that overlay edges don't get blurry.\n      ctx.moveTo(x0 - 1, y0 - 1);\n      ctx.lineTo(x3 + 1, y0 - 1);\n      ctx.lineTo(x3 + 1, y3 + 1);\n      ctx.lineTo(x0 - 1, y3 - 1);\n      ctx.lineTo(x0 - 1, y0 - 1);\n      ctx.closePath();\n\n      // Draw inner rectangle.\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x1, y2);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x1, y1);\n\n      ctx.closePath();\n      ctx.fill();\n    },\n\n    _renderBorders: function(ctx) {\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2, -this.getHeight()/2); // upper left\n      ctx.lineTo(this.getWidth()/2, -this.getHeight()/2); // upper right\n      ctx.lineTo(this.getWidth()/2, this.getHeight()/2); // down right\n      ctx.lineTo(-this.getWidth()/2, this.getHeight()/2); // down left\n      ctx.lineTo(-this.getWidth()/2, -this.getHeight()/2); // upper left\n      ctx.stroke();\n    },\n\n    _renderGrid: function(ctx) {\n      return;\n      // Vertical lines\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2 + 1/3 * this.getWidth(), -this.getHeight()/2);\n      ctx.lineTo(-this.getWidth()/2 + 1/3 * this.getWidth(), this.getHeight()/2);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2 + 2/3 * this.getWidth(), -this.getHeight()/2);\n      ctx.lineTo(-this.getWidth()/2 + 2/3 * this.getWidth(), this.getHeight()/2);\n      ctx.stroke();\n      // Horizontal lines\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2, -this.getHeight()/2 + 1/3 * this.getHeight());\n      ctx.lineTo(this.getWidth()/2, -this.getHeight()/2 + 1/3 * this.getHeight());\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(-this.getWidth()/2, -this.getHeight()/2 + 2/3 * this.getHeight());\n      ctx.lineTo(this.getWidth()/2, -this.getHeight()/2 + 2/3 * this.getHeight());\n      ctx.stroke();\n    }\n  });\n\n  var CropPlugin = Imager.Plugin.inherit({\n    // Init point\n    startX: null,\n    startY: null,\n\n    // Keycrop\n    isKeyCroping: false,\n    isKeyLeft: false,\n    isKeyUp: false,\n\n    defaults: {\n      // min crop dimension\n      minHeight: 1,\n      minWidth: 1,\n      // ensure crop ratio\n      ratio: null,\n      // quick crop feature (set a key code to enable it)\n      quickCropKey: false\n    },\n\n     init : function(imager,options) {\n      this.overrided(imager,options);\n      var buttonGroup = this.imager.toolbar.createButtonGroup();\n\n      this.cropButton = buttonGroup.createButton({\n        image: 'crop'\n      });\n      this.okButton = buttonGroup.createButton({\n        image: 'done',\n        type: 'success',\n        hide: true\n      });\n      this.cancelButton = buttonGroup.createButton({\n        image: 'close',\n        type: 'danger',\n        hide: true\n      });\n\n      // Buttons click\n      this.cropButton.addEventListener('click', this.toggleCrop.bind(this));\n      this.okButton.addEventListener('click', this.cropCurrentZone.bind(this));\n      this.cancelButton.addEventListener('click', this.releaseFocus.bind(this));\n\n      // Canvas events\n      this.imager.canvas.on('mouse:down', this.onMouseDown.bind(this));\n      this.imager.canvas.on('mouse:move', this.onMouseMove.bind(this));\n      this.imager.canvas.on('mouse:up', this.onMouseUp.bind(this));\n      this.imager.canvas.on('object:moving', this.onObjectMoving.bind(this));\n      this.imager.canvas.on('object:scaling', this.onObjectScaling.bind(this));\n\n      canvas2d.util.addListener(document, 'keydown', this.onKeyDown.bind(this));\n      canvas2d.util.addListener(document, 'keyup', this.onKeyUp.bind(this));\n\n      this.imager.addEventListener('core:transformation', this.releaseFocus.bind(this));\n    },\n\n    // Avoid crop zone to go beyond the canvas edges\n    onObjectMoving: function(event) {\n      if (!this.hasFocus()) {\n        return;\n      }\n\n      var currentObject = event.target;\n      if (currentObject !== this.cropZone)\n        return;\n\n      var canvas = this.imager.canvas;\n      var x = currentObject.getLeft(), y = currentObject.getTop();\n      var w = currentObject.getWidth(), h = currentObject.getHeight();\n      var maxX = canvas.getWidth() - w;\n      var maxY = canvas.getHeight() - h;\n\n      if (x < 0)\n        currentObject.set('left', 0);\n      if (y < 0)\n        currentObject.set('top', 0);\n      if (x > maxX)\n        currentObject.set('left', maxX);\n      if (y > maxY)\n        currentObject.set('top', maxY);\n\n      this.imager.dispatchEvent('crop:update');\n    },\n\n    // Prevent crop zone from going beyond the canvas edges (like mouseMove)\n    onObjectScaling: function(event) {\n      if (!this.hasFocus()) {\n        return;\n      }\n\n      var preventScaling = false;\n      var currentObject = event.target;\n      if (currentObject !== this.cropZone)\n        return;\n\n      var canvas = this.imager.canvas;\n      var pointer = canvas.getPointer(event.e);\n      var x = pointer.x;\n      var y = pointer.y;\n\n      var minX = currentObject.getLeft();\n      var minY = currentObject.getTop();\n      var maxX = currentObject.getLeft() + currentObject.getWidth();\n      var maxY = currentObject.getTop() + currentObject.getHeight();\n\n      if (null !== this.options.ratio) {\n        if (minX < 0 || maxX > canvas.getWidth() || minY < 0 || maxY > canvas.getHeight()) {\n          preventScaling = true;\n        }\n      }\n\n      if (minX < 0 || maxX > canvas.getWidth() || preventScaling) {\n        var lastScaleX = this.lastScaleX || 1;\n        currentObject.setScaleX(lastScaleX);\n      }\n      if (minX < 0) {\n        currentObject.setLeft(0);\n      }\n\n      if (minY < 0 || maxY > canvas.getHeight() || preventScaling) {\n        var lastScaleY = this.lastScaleY || 1;\n        currentObject.setScaleY(lastScaleY);\n      }\n      if (minY < 0) {\n        currentObject.setTop(0);\n      }\n\n      if (currentObject.getWidth() < this.options.minWidth) {\n        currentObject.scaleToWidth(this.options.minWidth);\n      }\n      if (currentObject.getHeight() < this.options.minHeight) {\n        currentObject.scaleToHeight(this.options.minHeight);\n      }\n\n      this.lastScaleX = currentObject.getScaleX();\n      this.lastScaleY = currentObject.getScaleY();\n\n      this.imager.dispatchEvent('crop:update');\n    },\n\n    // Init crop zone\n    onMouseDown: function(event) {\n      if (!this.hasFocus()) {\n        return;\n      }\n\n      var canvas = this.imager.canvas;\n\n      // recalculate offset, in case canvas was manipulated since last `calcOffset`\n      canvas.calcOffset();\n      var pointer = canvas.getPointer(event.e);\n      var x = pointer.x;\n      var y = pointer.y;\n      var point = new canvas2d.Point(x, y);\n\n      // Check if user want to scale or drag the crop zone.\n      var activeObject = canvas.getActiveObject();\n      if (activeObject === this.cropZone || this.cropZone.containsPoint(point)) {\n        return;\n      }\n\n      canvas.discardActiveObject();\n      this.cropZone.setWidth(0);\n      this.cropZone.setHeight(0);\n      this.cropZone.setScaleX(1);\n      this.cropZone.setScaleY(1);\n\n      this.startX = x;\n      this.startY = y;\n    },\n\n    // Extend crop zone\n    onMouseMove: function(event) {\n      // Quick crop feature\n      if (this.isKeyCroping)\n        return this.onMouseMoveKeyCrop(event);\n\n      if (null === this.startX || null === this.startY) {\n        return;\n      }\n\n      var canvas = this.imager.canvas;\n      var pointer = canvas.getPointer(event.e);\n      var x = pointer.x;\n      var y = pointer.y;\n\n      this._renderCropZone(this.startX, this.startY, x, y);\n    },\n\n    onMouseMoveKeyCrop: function(event) {\n      var canvas = this.imager.canvas;\n      var zone = this.cropZone;\n\n      var pointer = canvas.getPointer(event.e);\n      var x = pointer.x;\n      var y = pointer.y;\n\n      if (!zone.left || !zone.top) {\n        zone.setTop(y);\n        zone.setLeft(x);\n      }\n\n      this.isKeyLeft =  x < zone.left + zone.width / 2 ;\n      this.isKeyUp = y < zone.top + zone.height / 2 ;\n\n      this._renderCropZone(\n        Math.min(zone.left, x),\n        Math.min(zone.top, y),\n        Math.max(zone.left+zone.width, x),\n        Math.max(zone.top+zone.height, y)\n      );\n    },\n\n    // Finish crop zone\n    onMouseUp: function(event) {\n      if (null === this.startX || null === this.startY) {\n        return;\n      }\n\n      var canvas = this.imager.canvas;\n      this.cropZone.setCoords();\n      canvas.setActiveObject(this.cropZone);\n      canvas.calcOffset();\n\n      this.startX = null;\n      this.startY = null;\n    },\n\n    onKeyDown: function(event) {\n      if (false === this.options.quickCropKey || event.keyCode !== this.options.quickCropKey || this.isKeyCroping)\n        return;\n\n      // Active quick crop flow\n      this.isKeyCroping = true ;\n      this.imager.canvas.discardActiveObject();\n      this.cropZone.setWidth(0);\n      this.cropZone.setHeight(0);\n      this.cropZone.setScaleX(1);\n      this.cropZone.setScaleY(1);\n      this.cropZone.setTop(0);\n      this.cropZone.setLeft(0);\n    },\n\n    onKeyUp: function(event) {\n      if (false === this.options.quickCropKey || event.keyCode !== this.options.quickCropKey || !this.isKeyCroping)\n        return;\n\n      // Unactive quick crop flow\n      this.isKeyCroping = false;\n      this.startX = 1;\n      this.startY = 1;\n      this.onMouseUp();\n    },\n\n    selectZone: function(x, y, width, height, forceDimension) {\n      if (!this.hasFocus())\n        this.requireFocus();\n\n      if (!forceDimension) {\n        this._renderCropZone(x, y, x+width, y+height);\n      } else {\n        this.cropZone.set({\n          'left': x,\n          'top': y,\n          'width': width,\n          'height': height\n        });\n      }\n\n      var canvas = this.imager.canvas;\n      canvas.bringToFront(this.cropZone);\n      this.cropZone.setCoords();\n      canvas.setActiveObject(this.cropZone);\n      canvas.calcOffset();\n\n      this.imager.dispatchEvent('crop:update');\n    },\n\n    toggleCrop: function() {\n      if (!this.hasFocus())\n        this.requireFocus();\n      else\n        this.releaseFocus();\n    },\n\n    cropCurrentZone: function() {\n      if (!this.hasFocus())\n        return;\n\n      // Avoid croping empty zone\n      if (this.cropZone.width < 1 && this.cropZone.height < 1)\n        return;\n\n      var image = this.imager.image;\n\n      // Compute crop zone dimensions\n      var top = this.cropZone.getTop() - image.getTop();\n      var left = this.cropZone.getLeft() - image.getLeft();\n      var width = this.cropZone.getWidth();\n      var height = this.cropZone.getHeight();\n\n      // Adjust dimensions to image only\n      if (top < 0) {\n        height += top;\n        top = 0;\n      }\n\n      if (left < 0) {\n        width += left;\n        left = 0;\n      }\n\n      // Apply crop transformation.\n      // Make sure to use relative dimension since the crop will be applied\n      // on the source image.\n      this.imager.applyTransformation(new Crop({\n        top: top / image.getHeight(),\n        left: left / image.getWidth(),\n        width: width / image.getWidth(),\n        height: height / image.getHeight(),\n      }));\n    },\n\n    // Test wether crop zone is set\n    hasFocus: function() {\n      return this.cropZone !== undefined;\n    },\n\n    // Create the crop zone\n    requireFocus: function() {\n      this.cropZone = new CropZone({\n        fill: 'transparent',\n        hasBorders: false,\n        originX: 'left',\n        originY: 'top',\n        //stroke: '#444',\n        //strokeDashArray: [5, 5],\n        //borderColor: '#444',\n        cornerColor: '#444',\n        cornerSize: 8,\n        transparentCorners: false,\n        lockRotation: true,\n        hasRotatingPoint: false,\n      });\n\n      if (null !== this.options.ratio) {\n        this.cropZone.set('lockUniScaling', true);\n      }\n\n      this.imager.canvas.add(this.cropZone);\n      this.imager.canvas.defaultCursor = 'crosshair';\n\n      this.cropButton.active(true);\n      this.okButton.hide(false);\n      this.cancelButton.hide(false);\n    },\n\n    // Remove the crop zone\n    releaseFocus: function() {\n      if (undefined === this.cropZone)\n        return;\n\n      this.cropZone.remove();\n      this.cropZone = undefined;\n\n      this.cropButton.active(false);\n      this.okButton.hide(true);\n      this.cancelButton.hide(true);\n\n      this.imager.canvas.defaultCursor = 'default';\n\n      this.imager.dispatchEvent('crop:update');\n    },\n\n    _renderCropZone: function(fromX, fromY, toX, toY) {\n      var canvas = this.imager.canvas;\n\n      var isRight = (toX > fromX);\n      var isLeft = !isRight;\n      var isDown = (toY > fromY);\n      var isUp = !isDown;\n\n      var minWidth = Math.min(+this.options.minWidth, canvas.getWidth());\n      var minHeight = Math.min(+this.options.minHeight, canvas.getHeight());\n\n      // Define corner coordinates\n      var leftX = Math.min(fromX, toX);\n      var rightX = Math.max(fromX, toX);\n      var topY = Math.min(fromY, toY);\n      var bottomY = Math.max(fromY, toY);\n\n      // Replace current point into the canvas\n      leftX = Math.max(0, leftX);\n      rightX = Math.min(canvas.getWidth(), rightX);\n      topY = Math.max(0, topY)\n      bottomY = Math.min(canvas.getHeight(), bottomY);\n\n      // Recalibrate coordinates according to given options\n      if (rightX - leftX < minWidth) {\n        if (isRight)\n          rightX = leftX + minWidth;\n        else\n          leftX = rightX - minWidth;\n      }\n      if (bottomY - topY < minHeight) {\n        if (isDown)\n          bottomY = topY + minHeight;\n        else\n          topY = bottomY - minHeight;\n      }\n\n      // Truncate truncate according to canvas dimensions\n      if (leftX < 0) {\n        // Translate to the left\n        rightX += Math.abs(leftX);\n        leftX = 0\n      }\n      if (rightX > canvas.getWidth()) {\n        // Translate to the right\n        leftX -= (rightX - canvas.getWidth());\n        rightX = canvas.getWidth();\n      }\n      if (topY < 0) {\n        // Translate to the bottom\n        bottomY += Math.abs(topY);\n        topY = 0\n      }\n      if (bottomY > canvas.getHeight()) {\n        // Translate to the right\n        topY -= (bottomY - canvas.getHeight());\n        bottomY = canvas.getHeight();\n      }\n\n      var width = rightX - leftX;\n      var height = bottomY - topY;\n      var currentRatio = width / height;\n\n      if (this.options.ratio && +this.options.ratio !== currentRatio) {\n        var ratio = +this.options.ratio;\n\n        if(this.isKeyCroping) {\n          isLeft = this.isKeyLeft;\n          isUp = this.isKeyUp;\n        }\n\n        if (currentRatio < ratio) {\n          var newWidth = height * ratio;\n          if (isLeft) {\n            leftX -= (newWidth - width);\n          }\n          width = newWidth;\n        } else if (currentRatio > ratio) {\n          var newHeight = height / (ratio * height/width);\n          if (isUp) {\n            topY -= (newHeight - height);\n          }\n          height = newHeight;\n        }\n\n        if (leftX < 0) {\n          leftX = 0;\n          //TODO\n        }\n        if (topY < 0) {\n          topY = 0;\n          //TODO\n        }\n        if (leftX + width > canvas.getWidth()) {\n          var newWidth = canvas.getWidth() - leftX;\n          height = newWidth * height / width;\n          width = newWidth;\n          if (isUp) {\n            topY = fromY - height;\n          }\n        }\n        if (topY + height > canvas.getHeight()) {\n          var newHeight = canvas.getHeight() - topY;\n          width = width * newHeight / height;\n          height = newHeight;\n          if (isLeft) {\n            leftX = fromX - width;\n          }\n        }\n      }\n\n      // Apply coordinates\n      this.cropZone.left = leftX;\n      this.cropZone.top = topY;\n      this.cropZone.width = width;\n      this.cropZone.height = height;\n\n      this.imager.canvas.bringToFront(this.cropZone);\n\n      this.imager.dispatchEvent('crop:update');\n    }\n  });\n\n  var pluginInfo = {\n    name : \"crop\",\n    ctor : CropPlugin\n  };\n\n  Imager.installPlugin(pluginInfo);\n\n  return pluginInfo;\n\n});\n"]}